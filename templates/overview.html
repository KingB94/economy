<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Economic Data Dashboard</title>
  <!-- Google Fonts for professional typography -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700&display=swap" rel="stylesheet" />
  <!-- jQuery (for other libraries if needed) -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <!-- Chart.js and ChartDataLabels -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
  <!-- noUiSlider CSS and JS -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.js"></script>
  <!-- D3.js and TopoJSON -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <!-- Vue 2 and Vue Treeselect -->
  <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/@riophae/vue-treeselect@0.4.0/dist/vue-treeselect.umd.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@riophae/vue-treeselect@0.4.0/dist/vue-treeselect.min.css">
  <!-- Font Awesome CSS for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  <style>
    /* Global Reset & Box Sizing */
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background-color: #121212;
      color: #e0e0e0;
      -webkit-font-smoothing: antialiased;
    }

    /* Header with two sections: top row and controls row */
    header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      width: 100%;
      z-index: 1000;
      background: linear-gradient(135deg, #1f1f1f, #323232);
      padding: 10px 20px;
      display: flex;
      align-items: center;
      flex-wrap: nowrap;
    }

    .header-item {
      margin: 0 10px;
    }

    /* Headline takes minimal space */
    .header-headline {
      flex: 0.5;
      text-align: left;
    }

    .header-headline h1 {
      font-size: 18px;
      margin: 0;
    }

    /* Year slider gets the most space */
    .header-yearslider {
      flex: 3;
      text-align: center;
    }

    /* Country filter takes moderate space */
    .header-countryfilter {
      flex: 1;
      text-align: right;
    }

    .burger-icon,
    .account-icon {
      font-size: 24px;
      cursor: pointer;
      color: #e0e0e0;
    }

    .noUi-connect {
      background: rgba(50, 50, 50, 0.9);
    }

    /* Style for filter items moved into header-controls */
    .filter-item {
      display: flex;
      flex-direction: column;
    }

    .filter-label {
      font-weight: 500;
      margin-bottom: 5px;
      color: #e0e0e0;
      font-size: 14px;
    }

    /* Sidebar */
    .sidebar {
      height: 100%;
      width: 250px;
      position: fixed;
      top: 0;
      left: -250px;
      background-color: #1f1f1f;
      overflow-x: hidden;
      transition: left 0.3s ease;
      z-index: 1200;
      padding-top: 60px;
      color: #e0e0e0;
    }

    .sidebar.active {
      left: 0;
    }

    .sidebar .close-sidebar {
      position: absolute;
      top: 15px;
      right: 20px;
      font-size: 24px;
      cursor: pointer;
      color: #e0e0e0;
    }

    .sidebar .main-nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .sidebar .main-nav ul li {
      padding: 15px 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .sidebar .main-nav ul li a {
      text-decoration: none;
      color: #e0e0e0;
      font-weight: 500;
      display: block;
    }

    .sidebar .main-nav ul li a:hover {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }

    /* Overlay */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      z-index: 1150;
      display: none;
    }

    .overlay.active {
      display: block;
    }

    .global-blur-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(5px);
      z-index: 1500;
      display: none;
    }

    .global-blur-overlay.active {
      display: block;
    }

    /* Main container */
    .container {
      max-width: 1400px;
      margin: 100px auto 20px auto;
      padding: 20px;
      background: #1e1e1e;
      border-radius: 8px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.7);
      position: relative;
    }

    /* Main Indicator Wrapper */
    #mainIndicatorWrapper {
      text-align: center;
      margin-bottom: 20px;
      font-size: 22px;
      color: #e0e0e0;
    }

    #mainIndicatorSelect {
      font-size: 16px;
      padding: 4px 8px;
      margin-left: 10px;
      border: 1px solid #3d3d3d;
      border-radius: 4px;
      background-color: #121212;
      color: #e0e0e0;
    }

    /* Chart Layout */
    .chart-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 30px;
    }

    .chart-container {
      min-width: 300px;
      height: 500px;
      background: #2c2c2c;
      border: 1px solid #3d3d3d;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.7);
    }

    /* Expand Button */
    .expand-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: none;
      color: #e0e0e0;
      border-radius: 3px;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s ease;
      z-index: 10;
    }

    .expand-btn:hover {
      background: rgba(0, 0, 0, 0.7);
    }

    /* Remove Group Button */
    .remove-group-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #e74c3c;
      color: #fff;
      border: none;
      border-radius: 3px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s ease;
      z-index: 10;
    }

    .remove-group-btn:hover {
      background: #c0392b;
    }

    /* Expanded container styling now set to 80% viewport size */
    .chart-container.expanded,
    .additional-chart.expanded {
      position: fixed;
      top: 10%;
      left: 10%;
      width: 80%;
      height: 80%;
      z-index: 9999;
      background: #1f1f1f;
      padding: 20px;
      overflow: auto;
    }

    /* D3 bar chart internal styling */
    #barChartContainer {
      overflow-y: auto;
      position: relative;
    }

    .chart-container.expanded #barChartContent {
      width: 100%;
      height: 100%;
    }

    .chart-container.expanded #barChartContent svg {
      width: 100% !important;
      height: 100% !important;
    }

    /* Bar Chart Styles */
    .bar {
      transition: fill 0.2s ease;
    }

    .bar:hover {
      fill: darkorange;
    }

    .bar-text {
      fill: #e0e0e0;
      font-size: 12px;
      text-anchor: start;
    }

    .country-label {
      font-size: 12px;
      text-anchor: end;
      fill: #e0e0e0;
    }

    /* Map container */
    #d3Map {
      width: 100%;
      height: 100%;
    }

    /* Additional Groups */
    .additional-group {
      position: relative;
      /* Make positioning relative to this container */
    }

    .additional-threshold-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      max-width: 300px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* New Main Threshold Controls styling for main charts */
    .main-threshold-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      max-width: 300px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .group-indicator-select {
      font-size: 16px;
      padding: 4px 8px;
      border: 1px solid #3d3d3d;
      border-radius: 4px;
      background: #121212;
      color: #e0e0e0;
      margin: 0 auto;
      display: block;
    }

    .additional-charts-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .additional-chart {
      min-width: 300px;
      height: 500px;
      position: relative;
      background: #2c2c2c;
      border: 1px solid #3d3d3d;
      border-radius: 8px;
      overflow-y: auto;
      overflow-x: hidden;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.7);
    }

    .additional-chart canvas {
      width: 100% !important;
      height: 100% !important;
    }

    .chart-content {
      position: relative;
      width: 100%;
      height: 100%;
      margin-top: 0;
    }

    /* Additional Charts Control */
    #additionalChartsControl {
      text-align: center;
      margin: 30px 0 10px 0;
    }

    #additionalIndicatorSelect {
      font-size: 16px;
      padding: 6px 10px;
      margin-right: 10px;
      border: 1px solid #3d3d3d;
      border-radius: 4px;
      background: #121212;
      color: #e0e0e0;
    }

    #addChartButton {
      font-size: 16px;
      padding: 6px 12px;
      cursor: pointer;
      background: #1f1f1f;
      color: #e0e0e0;
      border: none;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    #addChartButton:hover {
      background: #323232;
    }

    /* Tooltip styling */
    #tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(50, 50, 50, 0.9);
      color: #e0e0e0;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      display: none;
      z-index: 10000;
    }

    /* Modal CSS */
    .modal {
      position: fixed;
      z-index: 10000;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.7);
      display: none;
    }

    .modal-content {
      position: relative;
      margin: 5% auto;
      padding: 20px;
      width: 90vw;
      min-height: 90vh;
      background: #1f1f1f;
      border-radius: 8px;
      color: #e0e0e0;
    }

    .close {
      position: absolute;
      top: 10px;
      right: 20px;
      color: #e0e0e0;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      transition: color 0.2s ease;
    }

    .close:hover {
      color: #fff;
    }

    /* Override Vue Treeselect text color */
    .vue-treeselect__control,
    .vue-treeselect__single-value,
    .vue-treeselect__placeholder,
    .vue-treeselect__multi-value-item,
    .vue-treeselect__option,
    .vue-treeselect__label {
      color: black !important;
    }

    .vue-treeselect__value-remove {
      color: black !important;
    }

    /* Fix Treeselect height and wrapping */
    .vue-treeselect__control {
      height: 36px !important;
      max-height: 36px !important;
      overflow: hidden !important;
    }

    .vue-treeselect__multi-value-wrapper {
      display: inline-flex !important;
      flex-wrap: nowrap !important;
      overflow-x: auto !important;
      overflow-y: hidden !important;
      white-space: nowrap !important;
      align-items: center !important;
      max-height: 36px !important;
    }

    .vue-treeselect__multi-value-item {
      white-space: nowrap !important;
      flex: 0 0 auto !important;
    }

    .vue-treeselect--searchable:not(.vue-treeselect--disabled) .vue-treeselect__value-container {
      cursor: text;
      max-height: 50px;
      overflow-y: auto;
    }

    .vue-treeselect--has-value .vue-treeselect__multi-value {
      margin-bottom: 5px;
      height: 25px;
    }
  </style>
</head>

<body>
  <!-- Sidebar Navigation -->
  <div class="sidebar" id="sidebar">
    <span class="close-sidebar" id="closeSidebar">&times;</span>
    <nav class="main-nav">
      <ul>
        <li><a href="comparative.html">Comparative View</a></li>
        <li><a href="data.html">Data</a></li>
      </ul>
    </nav>
  </div>
  <!-- Overlay -->
  <div class="overlay" id="overlay"></div>
  <!-- Global Blur Overlay -->
  <div id="globalBlurOverlay" class="global-blur-overlay"></div>
  <header class="header">
    <!-- Burger Menu Icon (Left) -->
    <div class="header-item header-menu" style="flex: 0.5; text-align: left;">
      <i id="burgerIcon" class="burger-icon fas fa-bars"></i>
    </div>
    <!-- Headline -->
    <div class="header-item header-headline" style="flex: 1; text-align: center;">
      <h1>Economic Data Dashboard</h1>
    </div>
    <!-- Year Slider -->
    <div class="header-item header-yearslider" style="flex: 3; text-align: center;">
      <label for="yearSlider" class="filter-label">Select Year(s):</label>
      <div id="yearSlider"></div>
      <span id="yearRangeDisplay">2019 - 2019</span>
    </div>
    <!-- Country Filter -->
    <div class="header-item header-countryfilter" id="vueCountrySelectContainer" style="flex: 1; text-align: center;">
      <label class="filter-label">Select Countries:</label>
      <treeselect v-model="selectedCountries" :options="countryOptions" :multiple="true" placeholder="Select countries" />
    </div>
    <!-- Account Icon (Right) -->
    <div class="header-item header-account" style="flex: 0.5; text-align: right;">
      <i id="accountIcon" class="account-icon fas fa-user"></i>
    </div>
  </header>
  <div class="container">
    <!-- Main Indicator Headline with Dropdown -->
    <div id="mainIndicatorWrapper">
      <select id="mainIndicatorSelect">
        <option value="NY.GDP.PCAP.CD">GDP per Capita (current US$)</option>
        <option value="NY.GDP.MKTP.CD">GDP (current US$)</option>
        <option value="SL.UEM.TOTL.ZS">Unemployment (% of total labor force)</option>
        <option value="FP.CPI.TOTL.ZG">Inflation (annual %)</option>
      </select>
    </div>
    <!-- Main Charts: Map & Bar Chart in Grid Layout (50:50) -->
    <div class="chart-row">
      <!-- D3.js World Map Container (Left) -->
      <div class="chart-container" id="mapContainer" data-chart-type="map">
        <button class="expand-btn" title="Expand Chart">⛶</button>
        <svg id="d3Map" width="960" height="500" viewBox="0 0 960 500"></svg>
      </div>
      <!-- D3 Horizontal Bar Chart Container (Right) -->
      <div class="chart-container" id="barChartContainer">
        <button class="expand-btn" title="Expand Chart">⛶</button>
        <div id="barChartContent"></div>
        <!-- Main Threshold Controls positioned at bottom right of this container -->
        <div class="main-threshold-controls">
          <div style="display: flex; align-items: center;">
            <div style="width: 30px; text-align: center;">
              <i class="fas fa-fire" style="color: red;"></i>
            </div>
            <label style="display: flex; align-items: center; margin-left: 10px;">
              &ge;&nbsp;
              <input type="number" id="redThreshold" value="5" step="0.1" style="width: 60px; margin: 0 5px;" />%
            </label>
          </div>
          <div style="display: flex; align-items: center;">
            <div style="width: 30px; text-align: center;">
              <i class="fas fa-adjust" style="color: orange;"></i>
            </div>
            <div style="margin-left: 10px; font-size: 14px;">Medium Threshold</div>
          </div>
          <div style="display: flex; align-items: center;">
            <div style="width: 30px; text-align: center;">
              <i class="fas fa-snowflake" style="color: blue;"></i>
            </div>
            <label style="display: flex; align-items: center; margin-left: 10px;">
              &le;&nbsp;
              <input type="number" id="blueThreshold" value="0" step="0.1" style="width: 60px; margin: 0 5px;" />%
            </label>
          </div>
        </div>
      </div>
    </div>
    <!-- Additional Charts Section -->
    <div class="additional-charts-section">
      <div id="additionalGroupsContainer"></div>
      <!-- Additional Charts Control (always appears at the bottom) -->
      <div id="additionalChartsControl">
        <select id="additionalIndicatorSelect"></select>
        <button id="addChartButton">Add Charts</button>
      </div>
    </div>
  </div>
  <!-- Tooltip for the world map -->
  <div id="tooltip"></div>
  <!-- Modal for Expanded Horizontal Bar Chart -->
  <div id="chartModal" class="modal">
    <div class="modal-content">
      <span id="modalClose" class="close">&times;</span>
      <div id="modalChartContainer"></div>
    </div>
  </div>
  <!-- Vue Instance for Treeselect -->
  <script>
    Vue.component('treeselect', VueTreeselect.Treeselect);
    // Save the Vue instance globally for state load
    window.vueCountrySelectVm = new Vue({
      el: '#vueCountrySelectContainer',
      data: { selectedCountries: [], countryOptions: [] },
      watch: {
        selectedCountries(newVal) {
          window.selectedCountries = newVal;
          updateDashboard();
        }
      },
      created() {
        if (window.countriesInfo) { this.buildOptions(); }
        else {
          const interval = setInterval(() => {
            if (window.countriesInfo) { clearInterval(interval); this.buildOptions(); }
          }, 100);
        }
      },
      methods: {
        buildOptions() {
          const regionsMap = {};
          window.countriesInfo.forEach(country => {
            let regionName = country.region.value.trim();
            if (!regionName) regionName = "Other";
            if (!regionsMap[regionName]) { regionsMap[regionName] = []; }
            regionsMap[regionName].push({ id: country.name, label: country.name });
          });
          this.countryOptions = Object.keys(regionsMap).map(region => ({
            id: region, label: region, children: regionsMap[region]
          }));
          window.countryOptions = this.countryOptions;
          this.selectedCountries = [];
          window.selectedCountries = this.selectedCountries;
          updateDashboard();
        }
      }
    });
  </script>
  <!-- Sidebar, Map, and Additional Groups Scripts -->
  <script>
    const burgerIcon = document.getElementById('burgerIcon');
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('overlay');
    const closeSidebar = document.getElementById('closeSidebar');
    burgerIcon.addEventListener('click', () => { sidebar.classList.add('active'); overlay.classList.add('active'); });
    closeSidebar.addEventListener('click', () => { sidebar.classList.remove('active'); overlay.classList.remove('active'); });
    overlay.addEventListener('click', () => { sidebar.classList.remove('active'); overlay.classList.remove('active'); });
    const accountIcon = document.getElementById('accountIcon');
    accountIcon.addEventListener('click', () => { window.location.href = "account.html"; });
  </script>
  <!-- Updated Chart Scripts -->
  <script>
    let countriesInfo = null;
    const countriesMapping = {}; // For flag images (ISO2 codes)
    const iso3Mapping = {}; // For deep dive URLs (ISO3 codes)
    window.countriesInfo = null;
    window.selectedCountries = [];
    window.filteredCountries = new Set();
    const indicators = [
      { id: "NY.GDP.PCAP.CD", name: "GDP per Capita (current US$)" },
      { id: "NY.GDP.MKTP.CD", name: "GDP (current US$)" },
      { id: "SL.UEM.TOTL.ZS", name: "Unemployment (% of total labor force)" },
      { id: "FP.CPI.TOTL.ZG", name: "Inflation (annual %)" }
    ];
    let mainIndicator = indicators[0].id;
    let mainIndicatorName = indicators[0].name;
    // Dynamic color scale function
    function getUserDefinedColorScale(minValue, maxValue) {
      return d3.scaleLinear()
        .domain([minValue, maxValue])
        .range(["lightblue", "darkblue"]);
    }
    const getValueFormatter = indicator => {
      if (indicator === "NY.GDP.PCAP.CD" || indicator === "NY.GDP.MKTP.CD")
        return d3.format("$.2s");
      else if (indicator === "SL.UEM.TOTL.ZS" || indicator === "FP.CPI.TOTL.ZG")
        return d => d3.format(",.1f")(d) + "%";
      else return d3.format(",.0f");
    };
    // Main threshold function using main controls
    function thresholdColor(deviation) {
      const blueThreshold = +document.getElementById("blueThreshold").value;
      const redThreshold = +document.getElementById("redThreshold").value;
      if (deviation < blueThreshold) return "blue";
      else if (deviation > redThreshold) return "red";
      else return "orange";
    }
    // Local additional threshold function for each additional group (reads from local controls)
    function localAdditionalThresholdColor(container, deviation) {
      // If container is missing or does not support .closest, fall back to thresholdColor
      if (!container || typeof container.closest !== 'function') {
        return thresholdColor(deviation);
      }
      const group = container.closest('.additional-group');
      // If group is null, also fallback to the default thresholdColor
      if (!group) {
        return thresholdColor(deviation);
      }
      const blueInput = group.querySelector('.additionalBlueThreshold');
      const redInput = group.querySelector('.additionalRedThreshold');
      const blueThreshold = blueInput ? +blueInput.value : 0;
      const redThreshold = redInput ? +redInput.value : 5;
      if (deviation < blueThreshold) return "blue";
      else if (deviation > redThreshold) return "red";
      else return "orange";
    }
    function populateIndicatorSelect(selectElement) {
      selectElement.innerHTML = "";
      indicators.forEach(ind => {
        const option = document.createElement("option");
        option.value = ind.id;
        option.textContent = ind.name;
        selectElement.appendChild(option);
      });
    }
    const mainIndicatorSelect = document.getElementById("mainIndicatorSelect");
    populateIndicatorSelect(mainIndicatorSelect);
    mainIndicatorSelect.value = mainIndicator;
    const additionalIndicatorSelect = document.getElementById("additionalIndicatorSelect");
    populateIndicatorSelect(additionalIndicatorSelect);
    mainIndicatorSelect.addEventListener("change", function () {
      mainIndicator = this.value;
      mainIndicatorName = this.options[this.selectedIndex].textContent;
      updateDashboard();
    });
    const yearSlider = document.getElementById('yearSlider');
    noUiSlider.create(yearSlider, {
      start: [2019, 2019],
      connect: true,
      step: 1,
      range: { min: 1990, max: 2023 },
      format: { to: value => Math.round(value), from: value => Number(value) }
    });
    const yearRangeDisplay = document.getElementById('yearRangeDisplay');
    yearSlider.noUiSlider.on('update', values => { yearRangeDisplay.textContent = values.join(" - "); });
    yearSlider.noUiSlider.on('change', updateDashboard);
    // Attach event listeners for main threshold controls (update dashboard when values change)
    document.getElementById("blueThreshold").addEventListener("input", updateDashboard);
    document.getElementById("redThreshold").addEventListener("input", updateDashboard);
    // Also update the main charts when window is resized so that threshold controls update correctly
    window.addEventListener("resize", updateDashboard);
    async function fetchGDPData(yearRange, indicator) {
      const ind = indicator || "NY.GDP.PCAP.CD";
      let countryData = countriesInfo;
      if (!countryData) {
        const response = await fetch("countries.json");
        countryData = await response.json();
      }
      const countryCodes = countryData.map(country => country.id).join(";");
      if (!countryCodes) { throw new Error("No valid country codes found."); }
      const url = `https://api.worldbank.org/v2/country/${countryCodes}/indicator/${ind}?date=${yearRange}&format=json&per_page=1000`;
      const result = await fetch(url);
      const data = await result.json();
      if (!data || data.length < 2 || !Array.isArray(data[1])) { throw new Error("Invalid data received from World Bank API."); }
      return data[1];
    }
    function processGDPData(data, startYear, endYear) {
      const countryData = {};
      data.forEach(item => {
        if (item.value !== null) {
          const countryName = item.country.value;
          const value = item.value;
          const year = item.date;
          if (!countryData[countryName]) {
            countryData[countryName] = { total: 0, count: 0, values: {} };
          }
          countryData[countryName].total += value;
          countryData[countryName].count += 1;
          countryData[countryName].values[year] = value;
        }
      });
      const processed = [];
      for (const country in countryData) {
        const values = countryData[country].values;
        const avg = countryData[country].total / countryData[country].count;
        const obj = { country, avgGDP: avg };
        const endVal = values[endYear];
        if (endVal == null) continue;
        obj.endValue = endVal;
        if (startYear !== endYear) {
          const startVal = values[startYear];
          if (startVal != null && startVal !== 0) {
            obj.deviation = Math.round(((endVal - startVal) / startVal) * 100);
          } else { continue; }
        }
        processed.push(obj);
      }
      return processed;
    }
    function processMapData(data, startYear, endYear) {
      const countryData = {};
      data.forEach(item => {
        if (item.value !== null) {
          const iso3 = item.countryiso3code;
          const value = item.value;
          const year = item.date;
          if (!countryData[iso3]) { countryData[iso3] = { total: 0, count: 0, values: {} }; }
          countryData[iso3].total += value;
          countryData[iso3].count += 1;
          countryData[iso3].values[year] = value;
        }
      });
      const result = {};
      for (const iso3 in countryData) {
        const avg = countryData[iso3].total / countryData[iso3].count;
        if (startYear === endYear) { result[iso3] = avg; }
        else {
          const startVal = countryData[iso3].values[startYear];
          const endVal = countryData[iso3].values[endYear];
          if (startVal != null && endVal != null && startVal !== 0) {
            result[iso3] = Math.round(((endVal - startVal) / startVal) * 100);
          }
        }
      }
      return result;
    }
    function renderBarChartD3(data, yearRange, indicator, containerElement, indicatorFriendlyName) {
      const container = containerElement || document.getElementById("barChartContent");
      container.innerHTML = "";
      const barHeight = 20;
      const margin = { top: 70, right: 100, bottom: 20, left: 180 };
      const years = yearRange.split(":");
      const isSingleYear = (years[0] === years[1]);
      // Determine if this chart is an additional chart.
      const additionalGroupContext =
        (containerElement && containerElement.closest && containerElement.closest('.additional-group')) ||
        containerElement._additionalGroup;
      const isAdditional = !!additionalGroupContext;
      data.forEach(d => { d.gdp = d.avgGDP; });
      // Always sort descending
      data.sort((a, b) => b.gdp - a.gdp);
      const containerWidth = container.clientWidth;
      const height = data.length * barHeight + margin.top + margin.bottom;
      const svg = d3.select(container)
        .append("svg")
        .attr("id", "chart")
        .attr("width", containerWidth)
        .attr("height", height);
      // Use the passed friendly name if provided; otherwise fall back to mainIndicatorName
      let chartIndicatorName = indicatorFriendlyName || mainIndicatorName; // default for main charts
      if (isAdditional) {
        const group = container.closest('.additional-group');
        chartIndicatorName = (group && group._indicatorName) ? group._indicatorName : (indicatorFriendlyName || indicator);
      }
      svg.append("text")
        .attr("class", "chart-headline")
        .attr("x", containerWidth / 2)
        .attr("y", 40)
        .attr("text-anchor", "middle")
        .style("fill", "#ffffff")
        .style("font-size", "20px")
        .style("font-weight", "bold")
        .text(years[1] + " | " + chartIndicatorName);
      const x = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.gdp)])
        .range([0, containerWidth - margin.left - margin.right]);
      const y = d3.scaleBand()
        .domain(data.map((d, i) => i))
        .range([margin.top, height - margin.bottom])
        .padding(0.1);
      const valueFormatter = getValueFormatter(indicator);
      const bars = svg.selectAll(".bar-group")
        .data(data)
        .enter()
        .append("g")
        .attr("class", "bar-group")
        .attr("transform", (d, i) => `translate(${margin.left}, ${y(i)})`)
        .style("cursor", "pointer")
        .on("click", (event, d) => {
          const iso = iso3Mapping[d.country.toLowerCase()] || d.country;
          window.location.href = "countries.html?country=" + encodeURIComponent(iso);
        });
      bars.append("text")
        .attr("class", "country-label")
        .attr("x", -70)
        .attr("y", y.bandwidth() / 2)
        .attr("dy", ".35em")
        .attr("text-anchor", "end")
        .style("fill", "#ffffff")
        .text(d => d.country);
      bars.append("image")
        .attr("xlink:href", d => {
          const iso = countriesMapping[d.country.toLowerCase()];
          return iso ? `https://flagcdn.com/${iso.toLowerCase()}.svg` : "";
        })
        .attr("x", -50)
        .attr("y", (y.bandwidth() - 16) / 2)
        .attr("width", 30)
        .attr("height", 16);
      bars.append("rect")
        .attr("class", "bar")
        .attr("x", 0)
        .attr("width", d => Math.max(x(d.gdp), 0))
        .attr("height", y.bandwidth())
        .attr("fill", function (d) {
          if (isSingleYear) {
            const values = data.map(d => d.endValue);
            const minValue = d3.min(values);
            const maxValue = d3.max(values);
            const colorScale = getUserDefinedColorScale(minValue, maxValue);
            return colorScale(d.endValue);
          } else {
            if (isAdditional) {
              return localAdditionalThresholdColor(additionalGroupContext, d.deviation);
            } else {
              return thresholdColor(d.deviation);
            }
          }
        });
      if (!isSingleYear) {
        bars.append("text")
          .attr("class", "percentage-label")
          .attr("x", 5)
          .attr("y", y.bandwidth() / 2)
          .attr("dy", ".35em")
          .style("fill", "#ffffff")
          .style("font-size", "12px")
          .text(d => (d.deviation >= 0 ? '+' : '') + d.deviation + '%');
        bars.filter((d, i) => i === 0)
          .select("text.percentage-label")
          .text(d => (d.deviation >= 0 ? '+' : '') + d.deviation + '% (since ' + years[0] + ')');
        bars.append("text")
          .attr("class", "threshold-icon")
          .attr("x", d => Math.max(x(d.gdp) - 20, 0))
          .attr("y", y.bandwidth() / 2)
          .attr("dy", ".35em")
          .style("font-family", '"Font Awesome 5 Free"')
          .style("font-weight", "900")
          .style("fill", "#ffffff")
          .style("font-size", "14px")
          .text(d => {
            const color = isAdditional ? localAdditionalThresholdColor(container, d.deviation) : thresholdColor(d.deviation);
            if (color === "red") return "\uf06d";
            else if (color === "orange") return "\uf042";
            else if (color === "blue") return "\uf2dc";
            else return "";
          });
      }
      bars.append("text")
        .attr("class", "bar-text")
        .attr("x", d => Math.max(x(d.gdp), 0))
        .attr("y", y.bandwidth() / 2)
        .attr("dy", ".35em")
        .style("fill", "#ffffff")
        .text(d => valueFormatter(d.endValue));
      window.addEventListener("resize", () => {
        const newWidth = container.clientWidth;
        svg.attr("width", newWidth);
        x.range([0, newWidth - margin.left - margin.right]);
        svg.selectAll("rect.bar").attr("width", d => Math.max(x(d.gdp), 0));
        svg.selectAll("text.bar-text").attr("x", d => Math.max(x(d.gdp), 0));
        if (!isSingleYear) {
          svg.selectAll("text.percentage-label").attr("x", 5);
          svg.selectAll("text.threshold-icon").attr("x", d => Math.max(x(d.gdp) - 20, 0));
        }
      });
    }
    // Updated updateAdditionalGroup to use local threshold controls within the group
    window.updateAdditionalGroup = async function (group) {
      if (!group._indicator) {
        group._worldMapContent.innerHTML = "";
        group._barChartContent.innerHTML = "";
        return;
      }
      try {
        const values = yearSlider.noUiSlider.get();
        const yearRangeParam = values.join(":");
        const [startYear, endYear] = yearRangeParam.split(":");
        const additionalControls = group.querySelector('.additional-threshold-controls');
        additionalControls.style.display = startYear === endYear ? 'none' : 'flex';

        const indicator = group._indicator;
        const indicatorName = group._indicatorName;
        // Get local threshold values from within the group
        const redThresholdInput = group.querySelector('.additionalRedThreshold');
        const blueThresholdInput = group.querySelector('.additionalBlueThreshold');
        const redThreshold = redThresholdInput ? +redThresholdInput.value : 5;
        const blueThreshold = blueThresholdInput ? +blueThresholdInput.value : 0;

        function groupAdditionalThresholdColor(deviation) {
          if (deviation < blueThreshold) return "blue";
          else if (deviation > redThreshold) return "red";
          else return "orange";
        }
        const rawData = await fetchGDPData(yearRangeParam, indicator);
        let processed = processGDPData(rawData, ...yearRangeParam.split(":"));
        processed.forEach(d => { d.gdp = d.avgGDP; });
        if (window.filteredCountries.size > 0) {
          processed = processed.filter(d => window.filteredCountries.has(d.country));
        }
        renderGroupWorldMap(group._worldMapContent, rawData, yearRangeParam, indicator, indicatorName, groupAdditionalThresholdColor, redThreshold, blueThreshold);
        // Pass the friendly name as the fifth argument for the additional chart.
        renderBarChartD3(processed, yearRangeParam, indicator, group._barChartContent, indicatorName);
      } catch (error) {
        console.error("Update additional group failed:", error);
      }
    };
    // Updated renderGroupWorldMap to accept a custom threshold function and group-specific thresholds for the legend
    function renderGroupWorldMap(container, rawData, year, indicator, indicatorName, thresholdFn, redThreshold, blueThreshold) {
      let svgWidth = container.clientWidth;
      let svgHeight = container.clientHeight;
      if (container.classList.contains("expanded")) {
        svgWidth = window.innerWidth;
        svgHeight = window.innerHeight;
      }
      const svg = d3.select(container)
        .html("")
        .append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight);
      // Append a headline at the top center.
      svg.append("text")
        .attr("class", "chart-headline")
        .attr("x", svgWidth / 2)
        .attr("y", 40)
        .attr("text-anchor", "middle")
        .style("fill", "#ffffff")
        .style("font-size", "20px")
        .style("font-weight", "bold")
        .text(indicatorName);
      if (worldGeoJSON) {
        const [startYear, endYear] = year.split(":");
        const mapData = processMapData(rawData, startYear, endYear);
        const projection = d3.geoMercator().fitSize([svgWidth, svgHeight], worldGeoJSON);
        const path = d3.geoPath().projection(projection);
        const g = svg.append("g");
        const valueFormatter = getValueFormatter(indicator);
        const isSingleYear = (startYear === endYear);
        const filteredCountries = window.filteredCountries || new Set();
        g.selectAll("path")
          .data(worldGeoJSON.features)
          .enter()
          .append("path")
          .attr("d", path)
          .attr("fill", d => {
            if (filteredCountries.size > 0 && !filteredCountries.has(d.properties.name))
              return "transparent";
            const isoCode = d.properties.iso_a3 || d.id;
            const value = mapData[isoCode] || 0;
            return isSingleYear
              ? (value > 0 ? getUserDefinedColorScale(d3.min(Object.values(mapData)), d3.max(Object.values(mapData)))(value) : "#444")
              : thresholdFn(value);
          })
          .attr("stroke", "#666")
          .attr("stroke-width", 0.5)
          .on("click", (event, d) => {
            const isoCode = d.properties.iso_a3 || d.id;
            window.location.href = "countries.html?country=" + isoCode;
          })
          .on("mouseover", function (event, d) {
            d3.select(this).attr("stroke-width", 2);
            d3.select("#tooltip")
              .style("display", "block")
              .html(`<strong>${d.properties.name}</strong><br>${indicatorName}: ${valueFormatter(mapData[d.properties.iso_a3 || d.id] || 0)}<br>Click to redirect`);
          })
          .on("mousemove", function (event) {
            d3.select("#tooltip")
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY + 10) + "px");
          })
          .on("mouseout", function () {
            d3.select(this).attr("stroke-width", 0.5);
            d3.select("#tooltip").style("display", "none");
          });
        const legendWidth = 200, legendHeight = 10;
        const legendX = svgWidth - legendWidth - 20, legendY = svgHeight - 40;
        const defs = svg.append("defs");
        const gradient = defs.append("linearGradient")
          .attr("id", "legend-gradient-additional")
          .attr("x1", "0%")
          .attr("y1", "0%")
          .attr("x2", "100%")
          .attr("y2", "0%");
        if (isSingleYear) {
          gradient.append("stop").attr("offset", "0%").attr("stop-color", "lightblue");
          gradient.append("stop").attr("offset", "100%").attr("stop-color", "darkblue");
        } else {
          gradient.append("stop").attr("offset", "0%").attr("stop-color", "blue");
          gradient.append("stop").attr("offset", "50%").attr("stop-color", "orange");
          gradient.append("stop").attr("offset", "100%").attr("stop-color", "red");
        }
        svg.append("rect")
          .attr("x", legendX)
          .attr("y", legendY)
          .attr("width", legendWidth)
          .attr("height", legendHeight)
          .style("fill", "url(#legend-gradient-additional)")
          .style("stroke", "#666")
          .style("stroke-width", 0.5);
        svg.append("text")
          .attr("x", legendX)
          .attr("y", legendY - 5)
          .attr("text-anchor", "start")
          .style("font-size", "12px")
          .style("fill", "#e0e0e0")
          .text(getValueFormatter(indicator)(blueThreshold));
        svg.append("text")
          .attr("x", legendX + legendWidth)
          .attr("y", legendY - 5)
          .attr("text-anchor", "end")
          .style("font-size", "12px")
          .style("fill", "#e0e0e0")
          .text(getValueFormatter(indicator)(redThreshold));
        const zoom = d3.zoom()
          .scaleExtent([1, 8])
          .on("zoom", event => { g.attr("transform", event.transform); });
        const initialTransform = d3.zoomIdentity.translate(-250, 0).scale(1.5);
        svg.call(zoom).call(zoom.transform, initialTransform);
      }
    }
    function openChartModal() {
      const modal = document.getElementById("chartModal");
      modal.style.display = "block";
      const modalContainer = document.getElementById("modalChartContainer");
      modalContainer.innerHTML = "";
      const values = yearSlider.noUiSlider.get();
      const yearRangeParam = values.join(":");
      fetchGDPData(yearRangeParam, mainIndicator)
        .then(rawData => {
          let processed = processGDPData(rawData, ...yearRangeParam.split(":"));
          if (window.filteredCountries.size > 0) {
            processed = processed.filter(d => window.filteredCountries.has(d.country));
          }
          // Pass the friendly name as the fifth argument:
          renderBarChartD3(processed, yearRangeParam, mainIndicator, modalContainer, mainIndicatorName);
        })
        .catch(error => { console.error("Modal chart update failed:", error); });
    }
    function openAdditionalBarChartModal(group) {
      const modal = document.getElementById("chartModal");
      modal.style.display = "block";
      const modalContainer = document.getElementById("modalChartContainer");
      modalContainer.innerHTML = "";
      modalContainer._additionalGroup = group;
      const values = yearSlider.noUiSlider.get();
      const yearRangeParam = values.join(":");
      const indicator = group._indicator;
      fetchGDPData(yearRangeParam, indicator)
        .then(rawData => {
          let processed = processGDPData(rawData, ...yearRangeParam.split(":"));
          if (window.filteredCountries.size > 0) {
            processed = processed.filter(d => window.filteredCountries.has(d.country));
          }
          // Pass the friendly name from the group for the modal as well.
          renderBarChartD3(processed, yearRangeParam, indicator, modalContainer, group._indicatorName);
        })
        .catch(error => { console.error("Additional bar chart modal update failed:", error); });
    }
    document.getElementById("modalClose").addEventListener("click", function () {
      document.getElementById("chartModal").style.display = "none";
    });
    document.addEventListener("click", function (e) {
      if (e.target && e.target.classList.contains("expand-btn")) {
        const container = e.target.parentElement;
        if (container.id === "barChartContainer") { openChartModal(); }
        else if (container.dataset.chartType === "bar" && container.closest('.additional-group')) {
          const group = container.closest('.additional-group');
          openAdditionalBarChartModal(group);
        } else {
          container.classList.toggle("expanded");
          e.target.innerHTML = container.classList.contains("expanded") ? "✕" : "⛶";
          const blurOverlay = document.getElementById("globalBlurOverlay");
          if (container.classList.contains("expanded")) { blurOverlay.classList.add("active"); }
          else { blurOverlay.classList.remove("active"); }
          if (container.dataset.chartType === "map") {
            const group = e.target.closest('.additional-group');
            if (group) { updateAdditionalGroup(group); }
          }
        }
      }
    });
    document.getElementById("addChartButton").addEventListener("click", function () {
      const selectedIndicator = additionalIndicatorSelect.value;
      const newGroup = createAdditionalGroup(selectedIndicator, additionalIndicatorSelect.options[additionalIndicatorSelect.selectedIndex].textContent);
      document.getElementById("additionalGroupsContainer").appendChild(newGroup);
      updateAdditionalGroup(newGroup);
    });
    function createAdditionalGroup(indicator, indicatorName) {
      const groupContainer = document.createElement('div');
      groupContainer.className = 'additional-group';
      // Remove Button
      const removeBtn = document.createElement("button");
      removeBtn.className = "remove-group-btn";
      removeBtn.title = "Remove this chart group";
      removeBtn.textContent = "x";
      removeBtn.addEventListener("click", function () { groupContainer.remove(); saveState(); });
      groupContainer.appendChild(removeBtn);
      // Dropdown Wrapper
      const dropdownWrapper = document.createElement('div');
      dropdownWrapper.className = 'dropdown-wrapper';
      dropdownWrapper.style.textAlign = 'center';
      dropdownWrapper.style.padding = '10px 0';
      dropdownWrapper.style.background = '#2c2c2c';
      dropdownWrapper.style.borderBottom = '1px solid #3d3d3d';
      const groupIndicatorSelect = document.createElement('select');
      groupIndicatorSelect.className = 'group-indicator-select';
      indicators.forEach(ind => {
        const option = document.createElement("option");
        option.value = ind.id;
        option.textContent = ind.name;
        groupIndicatorSelect.appendChild(option);
      });
      groupIndicatorSelect.value = indicator;
      groupIndicatorSelect.addEventListener('change', function () {
        groupContainer._indicator = this.value;
        groupContainer._indicatorName = this.options[this.selectedIndex].textContent;
        updateAdditionalGroup(groupContainer);
        saveState();
      });
      dropdownWrapper.appendChild(groupIndicatorSelect);
      groupContainer.appendChild(dropdownWrapper);
      // Charts Container
      const chartsContainer = document.createElement('div');
      chartsContainer.className = 'additional-charts-container';
      // World Map Chart
      const worldMapChartDiv = document.createElement('div');
      worldMapChartDiv.className = 'additional-chart';
      worldMapChartDiv.dataset.chartType = "map";
      const expandBtn1 = document.createElement("button");
      expandBtn1.className = "expand-btn";
      expandBtn1.title = "Expand Chart";
      expandBtn1.innerHTML = "⛶";
      worldMapChartDiv.appendChild(expandBtn1);
      const worldMapContentDiv = document.createElement('div');
      worldMapContentDiv.className = 'chart-content';
      worldMapChartDiv.appendChild(worldMapContentDiv);
      // Bar Chart
      const barChartDiv = document.createElement('div');
      barChartDiv.className = 'additional-chart';
      barChartDiv.dataset.chartType = "bar";
      const expandBtn2 = document.createElement("button");
      expandBtn2.className = "expand-btn";
      expandBtn2.title = "Expand Chart";
      expandBtn2.innerHTML = "⛶";
      barChartDiv.appendChild(expandBtn2);
      const barChartContentDiv = document.createElement('div');
      barChartContentDiv.className = 'chart-content';
      barChartDiv.appendChild(barChartContentDiv);
      chartsContainer.appendChild(worldMapChartDiv);
      chartsContainer.appendChild(barChartDiv);
      groupContainer.appendChild(chartsContainer);
      // Local Threshold Controls (moved to the bottom right)
      const thresholdControls = document.createElement('div');
      thresholdControls.className = 'additional-threshold-controls';
      // Fire Row
      const fireRow = document.createElement('div');
      fireRow.style.display = 'flex';
      fireRow.style.alignItems = 'center';
      fireRow.innerHTML = `
        <div style="width: 30px; text-align: center;">
          <i class="fas fa-fire" style="color: red;"></i>
        </div>
        <label style="display: flex; align-items: center; margin-left: 10px;">
          &ge;&nbsp;
          <input type="number" class="additionalRedThreshold" value="5" step="0.1" style="width: 60px; margin: 0 5px;" />%
        </label>
      `;
      thresholdControls.appendChild(fireRow);
      // Medium Row
      const mediumRow = document.createElement('div');
      mediumRow.style.display = 'flex';
      mediumRow.style.alignItems = 'center';
      mediumRow.innerHTML = `
        <div style="width: 30px; text-align: center;">
          <i class="fas fa-adjust" style="color: orange;"></i>
        </div>
        <div style="margin-left: 10px; font-size: 14px;">Medium Threshold</div>
      `;
      thresholdControls.appendChild(mediumRow);
      // Snowflake Row
      const snowflakeRow = document.createElement('div');
      snowflakeRow.style.display = 'flex';
      snowflakeRow.style.alignItems = 'center';
      snowflakeRow.innerHTML = `
        <div style="width: 30px; text-align: center;">
          <i class="fas fa-snowflake" style="color: blue;"></i>
        </div>
        <label style="display: flex; align-items: center; margin-left: 10px;">
          &le;&nbsp;
          <input type="number" class="additionalBlueThreshold" value="0" step="0.1" style="width: 60px; margin: 0 5px;" />%
        </label>
      `;
      thresholdControls.appendChild(snowflakeRow);
      groupContainer.appendChild(thresholdControls);
      groupContainer._indicator = indicator;
      groupContainer._indicatorName = indicatorName;
      groupContainer._worldMapContent = worldMapContentDiv;
      groupContainer._barChartContent = barChartContentDiv;
      // Add event listeners to local threshold inputs to update the charts when values change
      const additionalRedThresholdInput = thresholdControls.querySelector('.additionalRedThreshold');
      const additionalBlueThresholdInput = thresholdControls.querySelector('.additionalBlueThreshold');
      additionalRedThresholdInput.addEventListener('input', function () {
        updateAdditionalGroup(groupContainer);
        saveState();
      });
      additionalBlueThresholdInput.addEventListener('input', function () {
        updateAdditionalGroup(groupContainer);
        saveState();
      });
      return groupContainer;
    }
    let worldGeoJSON = null;
    Promise.all([
      fetch("countries.json").then(response => response.json()),
      d3.json("world.geojson")
    ]).then(([countriesData, worldData]) => {
      countriesInfo = countriesData;
      window.countriesInfo = countriesData;
      countriesData.forEach(d => {
        countriesMapping[d.name.toLowerCase()] = d.iso2Code;
        iso3Mapping[d.name.toLowerCase()] = d.id;
      });
      worldGeoJSON = worldData;
      updateDashboard();
    }).catch(error => { console.error("Error loading data:", error); });

    // NEW: Hide main threshold controls when a single year is selected.
    function updateThresholdControlsVisibility(startYear, endYear) {
      const mainControls = document.querySelector('.main-threshold-controls');
      if (startYear === endYear) {
        mainControls.style.display = 'none';
      } else {
        mainControls.style.display = 'flex';
      }
    }

    async function updateDashboard() {
      try {
        const values = yearSlider.noUiSlider.get();
        const yearRangeParam = values.join(":");
        const [startYear, endYear] = yearRangeParam.split(":");
        // Update visibility of main threshold controls based on the slider values.
        updateThresholdControlsVisibility(startYear, endYear);
        const selected = window.selectedCountries || [];
        let expandedSelected = new Set();
        if (window.countryOptions) {
          window.countryOptions.forEach(regionOption => {
            if (selected.includes(regionOption.id)) {
              regionOption.children.forEach(child => expandedSelected.add(child.id));
            }
          });
        }
        selected.forEach(sel => {
          if (!window.countryOptions || !window.countryOptions.find(opt => opt.id === sel))
            expandedSelected.add(sel);
        });
        window.filteredCountries = expandedSelected;
        const rawDataRange = await fetchGDPData(yearRangeParam, mainIndicator);
        const rawDataEnd = await fetchGDPData(`${endYear}:${endYear}`, mainIndicator);
        let processedRange = processGDPData(rawDataRange, startYear, endYear);
        let processedEnd = processGDPData(rawDataEnd, endYear, endYear);
        const endYearLookup = {};
        processedEnd.forEach(d => { endYearLookup[d.country] = d.endValue; });
        processedRange.forEach(d => { if (endYearLookup[d.country] !== undefined) d.endValue = endYearLookup[d.country]; });
        if (window.filteredCountries.size > 0) {
          processedRange = processedRange.filter(d => window.filteredCountries.has(d.country));
        }
        renderBarChartD3(processedRange, yearRangeParam, mainIndicator, document.getElementById("barChartContent"));
        if (worldGeoJSON) {
          const mapData = processMapData(rawDataRange, startYear, endYear);
          window.currentGdpLookup = mapData;
          updateD3MapChart(mapData, yearRangeParam, mainIndicator, mainIndicatorName);
        }
        document.querySelectorAll('.additional-group').forEach(group => { updateAdditionalGroup(group); });
      } catch (error) { console.error("Dashboard update failed:", error); }
      // Save state after every dashboard update
      saveState();
    }
    window.updateDashboard = updateDashboard;
    function updateD3MapChart(gdpLookup, year, indicator, indicatorName) {
      const svg = d3.select("#d3Map");
      svg.selectAll("*").remove();
      const width = +svg.attr("width");
      const height = +svg.attr("height");
      const years = year.split(":");
      const isSingleYear = (years[0] === years[1]);
      svg.append("text")
        .attr("class", "chart-headline")
        .attr("x", width / 2)
        .attr("y", -60)
        .attr("text-anchor", "middle")
        .style("fill", "#e0e0e0")
        .style("font-size", "30px")
        .style("font-weight", "bold")
        .text(years[1] + " | " + indicatorName);
      const projection = d3.geoMercator().fitSize([width, height], worldGeoJSON);
      const path = d3.geoPath().projection(projection);
      const g = svg.append("g").attr("transform", "translate(0,30)");
      const valueFormatter = getValueFormatter(indicator);
      const filteredCountries = window.filteredCountries || new Set();
      g.selectAll("path")
        .data(worldGeoJSON.features)
        .enter()
        .append("path")
        .attr("d", path)
        .attr("fill", d => {
          if (filteredCountries.size > 0 && !filteredCountries.has(d.properties.name))
            return "transparent";
          const isoCode = d.properties.iso_a3 || d.id;
          const value = gdpLookup[isoCode] || 0;
          return isSingleYear
            ? (value > 0 ? getUserDefinedColorScale(d3.min(Object.values(gdpLookup)), d3.max(Object.values(gdpLookup)))(value) : "#444")
            : thresholdColor(value);
        })
        .attr("stroke", "#666")
        .attr("stroke-width", 0.5)
        .on("click", (event, d) => {
          const isoCode = d.properties.iso_a3 || d.id;
          window.location.href = "countries.html?country=" + isoCode;
        })
        .on("mouseover", function (event, d) {
          d3.select(this).attr("stroke-width", 2);
          d3.select("#tooltip")
            .style("display", "block")
            .html(`<strong>${d.properties.name}</strong><br>${indicatorName}: ${valueFormatter(gdpLookup[d.properties.iso_a3 || d.id] || 0)}<br>Click for deep dive`);
        })
        .on("mousemove", function (event) {
          d3.select("#tooltip")
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY + 10) + "px");
        })
        .on("mouseout", function () {
          d3.select(this).attr("stroke-width", 0.5);
          d3.select("#tooltip").style("display", "none");
        });
      const legendWidth = 200, legendHeight = 10;
      const legendX = width - legendWidth - 20, legendY = height - 40;
      const defs = svg.append("defs");
      const gradient = defs.append("linearGradient")
        .attr("id", "legend-gradient")
        .attr("x1", "0%")
        .attr("y1", "0%")
        .attr("x2", "100%")
        .attr("y2", "0%");
      if (isSingleYear) {
        gradient.append("stop").attr("offset", "0%").attr("stop-color", "lightblue");
        gradient.append("stop").attr("offset", "100%").attr("stop-color", "darkblue");
      } else {
        gradient.append("stop").attr("offset", "0%").attr("stop-color", "blue");
        gradient.append("stop").attr("offset", "50%").attr("stop-color", "orange");
        gradient.append("stop").attr("offset", "100%").attr("stop-color", "red");
      }
      svg.append("rect")
        .attr("x", legendX)
        .attr("y", legendY)
        .attr("width", legendWidth)
        .attr("height", legendHeight)
        .style("fill", "url(#legend-gradient)")
        .style("stroke", "#666")
        .style("stroke-width", 0.5);
      const lowVal = isSingleYear ? 0 : +document.getElementById('blueThreshold').value;
      const highVal = isSingleYear ? 1e5 : +document.getElementById('redThreshold').value;
      svg.append("text")
        .attr("x", legendX)
        .attr("y", legendY - 5)
        .attr("text-anchor", "start")
        .style("font-size", "12px")
        .style("fill", "#e0e0e0")
        .text(getValueFormatter(indicator)(lowVal));
      svg.append("text")
        .attr("x", legendX + legendWidth)
        .attr("y", legendY - 5)
        .attr("text-anchor", "end")
        .style("font-size", "12px")
        .style("fill", "#e0e0e0")
        .text(getValueFormatter(indicator)(highVal));
      const zoom = d3.zoom()
        .scaleExtent([1, 8])
        .on("zoom", event => { g.attr("transform", event.transform); });
      const initialTransform = d3.zoomIdentity.translate(-250, 0).scale(1.5);
      svg.call(zoom).call(zoom.transform, initialTransform);
    }

    // --- State persistence functions ---
    function saveState() {
      const yearRange = yearSlider.noUiSlider.get();
      const mainIndicatorVal = mainIndicatorSelect.value;
      const selectedCountries = window.selectedCountries;
      const additionalGroupsState = Array.from(document.querySelectorAll('.additional-group')).map(group => {
        const indicator = group._indicator;
        const indicatorName = group._indicatorName;
        const additionalRedThreshold = group.querySelector('.additionalRedThreshold') ? group.querySelector('.additionalRedThreshold').value : null;
        const additionalBlueThreshold = group.querySelector('.additionalBlueThreshold') ? group.querySelector('.additionalBlueThreshold').value : null;
        return { indicator, indicatorName, additionalRedThreshold, additionalBlueThreshold };
      });
      const state = { yearRange, mainIndicatorVal, selectedCountries, additionalGroupsState };
      localStorage.setItem('dashboardState', JSON.stringify(state));
    }

    function loadState() {
      const stateStr = localStorage.getItem('dashboardState');
      if (!stateStr) return;
      const state = JSON.parse(stateStr);
      if (state.yearRange) {
        yearSlider.noUiSlider.set(state.yearRange);
      }
      if (state.mainIndicatorVal) {
        mainIndicatorSelect.value = state.mainIndicatorVal;
        mainIndicator = state.mainIndicatorVal;
        mainIndicatorName = mainIndicatorSelect.options[mainIndicatorSelect.selectedIndex].textContent;
      }
      if (state.selectedCountries) {
        window.selectedCountries = state.selectedCountries;
        if (window.vueCountrySelectVm) {
          window.vueCountrySelectVm.selectedCountries = state.selectedCountries;
        }
      }
      if (state.additionalGroupsState && Array.isArray(state.additionalGroupsState)) {
        const container = document.getElementById("additionalGroupsContainer");
        container.innerHTML = "";
        state.additionalGroupsState.forEach(groupState => {
          const newGroup = createAdditionalGroup(groupState.indicator, groupState.indicatorName);
          const redInput = newGroup.querySelector('.additionalRedThreshold');
          const blueInput = newGroup.querySelector('.additionalBlueThreshold');
          if (redInput && groupState.additionalRedThreshold) redInput.value = groupState.additionalRedThreshold;
          if (blueInput && groupState.additionalBlueThreshold) blueInput.value = groupState.additionalBlueThreshold;
          container.appendChild(newGroup);
          updateAdditionalGroup(newGroup);
        });
      }
    }
    // --- End state persistence functions ---

  </script>
  <script>
    // Load saved state on page load
    document.addEventListener("DOMContentLoaded", () => {
      loadState();
    });
  </script>
</body>

</html>
