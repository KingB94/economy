<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GDP History Dashboard</title>
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet" />

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    crossorigin="anonymous" referrerpolicy="no-referrer" />

  <!-- jQuery (required for Chart.js, D3, etc.) -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

  <!-- jQuery UI (for slider functionality) -->
  <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
  <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- D3.js -->
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <!-- Include html2canvas from a CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <!-- Vue 2.x -->
  <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
  <!-- vue-treeselect & its styles -->
  <script src="https://cdn.jsdelivr.net/npm/@riophae/vue-treeselect@0.4.0/dist/vue-treeselect.umd.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@riophae/vue-treeselect@0.4.0/dist/vue-treeselect.min.css">

  <!-- select2 dropdown for language selection-->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/css/select2.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.min.js"></script>

  <!-- PptxGenJS for Presentation Creation -->
  <script defer src="https://unpkg.com/pptxgenjs/dist/pptxgen.bundle.js"></script>

  <style>
    :root {
      /* Color Palette */
      --color-bg: #1a1a1a;
      --color-bg-light: #1a1a1a;
      --color-bg-medium: #333333;
      --color-bg-dark: #1a1a1a;
      --color-primary: #DB7C26;
      /* used for quadrant accents */
      --color-secondary: #C1121F;
      --color-tertiary: #669BBC;
      --color-accent: #228B22;
      --color-text: #fdf0d5;
      --vue-color: #fdf0d5;
      --color-border: rgba(255, 255, 255, 0.1);
      --color-shadow: rgba(0, 0, 0, 0.7);

      /* Quadrants */
      --quadrant-q1: #C1121F;
      --quadrant-q2: #DB7C26;
      --quadrant-q3: #669BBC;
      --quadrant-q4: #DB7C26;

      /* Typography */
      --font-primary: 'Montserrat', sans-serif;
      --font-secondary: 'Roboto', sans-serif;

      /* Sizing */
      --header-height: 80px;
      --sidebar-width: 250px;
      --transition-speed: 0.3s;
    }

    /* ---------- Global Reset & Base Styles ---------- */
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font-primary);
      background: var(--color-bg);
      color: var(--color-text);
    }

    /* ---------- Integrated Header ---------- */
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: var(--header-height);
      z-index: 1100;
      background: var(--color-bg-light);
      padding: 10px 20px;
      display: flex;
      align-items: center;
      font-family: var(--font-secondary);
    }

    .header-item {
      padding: 0 10px;
    }

    /* Make sure the header menu uses flex layout */
    .header-menu {
      display: flex;
      align-items: center;
    }

    .header-account {
      flex: 0.5;
    }

    /* Add some left margin to the dropdown for a gap */
    #savedDashboardsSelect+.select2-container {
      margin-left: 20px;
    }

    .header-headline {
      flex: 1;
      text-align: center;
    }

    .header-yearslider {
      flex: 3;
      text-align: center;
    }

    .header-countryfilter {
      flex: 1;
      text-align: center;
    }

    .burger-icon,
    .account-icon {
      font-size: 24px;
      cursor: pointer;
      color: var(--color-text);
    }

    header h1 {
      margin: 0;
      font-weight: 700;
      letter-spacing: 1px;
    }

    .filter-label {
      font-weight: 500;
      font-size: 14px;
      margin-bottom: 4px;
      display: block;
      color: var(--color-text);
    }

    /* New Mobile Header Styles */
    @media (max-width: 768px) {
      .header {
        flex-direction: column;
        height: auto;
        padding: 10px;
        text-align: center;
      }

      .header-item {
        padding: 5px 0;
        width: 100%;
      }

      .header-menu {
        order: 1;
      }

      .header-headline {
        order: 2;
        font-size: 18px;
      }

      .header-yearslider {
        order: 3;
      }

      .header-countryfilter {
        order: 4;
      }

      .header-account {
        display: none;
      }

      .dashboard-container {
        margin: 200px auto 20px auto !important;
      }
    }

    /* ---------- Navigation Sidebar ---------- */
    .sidebar {
      position: fixed;
      top: 0;
      left: -250px;
      width: var(--sidebar-width);
      height: 100%;
      background-color: var(--color-bg-light);
      overflow-x: hidden;
      transition: left var(--transition-speed) ease;
      z-index: 1200;
      padding-top: 60px;
      color: var(--color-text);
      font-family: var(--font-secondary);
    }

    .sidebar.active {
      left: 0;
    }

    .sidebar .close-sidebar {
      position: absolute;
      top: 15px;
      right: 20px;
      font-size: 24px;
      cursor: pointer;
      color: var(--color-text);
    }

    .sidebar .main-nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .sidebar .main-nav ul li {
      padding: 15px 20px;
      border-bottom: 1px solid var(--color-border);
    }

    .sidebar .main-nav ul li a {
      text-decoration: none;
      color: var(--color-text);
      font-weight: 500;
      display: block;
    }

    .sidebar .main-nav ul li.active a {
      background-color: #444;
      font-weight: bold;
    }

    .sidebar .main-nav ul li a:hover {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }

    /* ---------- Overlay for Sidebar ---------- */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(252, 249, 249, 0.6);
      z-index: 1150;
      display: none;
    }

    .overlay.active {
      display: block;
    }

    /* ---------- Dashboard Container ---------- */
    .dashboard-container {
      width: 100%;
      margin: var(--header-height) auto 20px auto;
    }

    /* ---------- Chart Grids Container ---------- */
    #chartGridsContainer {
      display: flex;
      flex-direction: column;
      gap: 40px;
      padding: 0 20px;
      overflow-x: auto;
    }

    /* ---------- Charts Grid ---------- */
    .charts-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      width: 100%;
      max-width: 100%;
      padding: 20px;
      margin-bottom: 10px;
      background: var(--color-bg-dark);
      border-radius: 8px;
      box-shadow: 0 4px 8px var(--color-shadow);
      position: relative;
    }

    @media (max-width: 768px) {
      .charts-grid {
        grid-template-columns: 1fr;
      }
    }

    /* ---------- Quadrant Chart ---------- */
    #quadrantLeftContainer1,
    [id^="quadrantLeftContainer"] {
      background: var(--color-bg-medium);
      padding: 10px;
      border-radius: 6px;
      position: relative;
    }

    #quadrantDropdownContainer1,
    [id^="quadrantDropdownContainer"] {
      margin-bottom: 10px;
      display: none;
    }

    /* ---------- Language selection ---------- */
    .select2-container--open {
      z-index: 1500 !important;
    }

    .select2-container--default .select2-selection--single {
      background-color: var(--vue-color);
      border: 1px solid #aaa;
      border-radius: 4px;
    }

    .select2-container--default .select2-results__option {
      color: #000 !important;
      background-color: var(--vue-color);
    }

    /* ---------- Line Chart Wrapper ---------- */
    .line-chart-wrapper {
      position: relative;
      background: var(--color-bg-medium);
      padding: 10px 10px 30px 10px;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      height: 330px;
      transition: all 0.3s ease;
    }

    .line-charts {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .chart-canvas {
      width: 100%;
      height: 100%;
    }

    .indicatorSelect {
      font-size: 1em;
      padding: 5px 8px;
      margin-bottom: 10px;
      border-radius: 4px;
      background: var(--color-bg-light);
      color: var(--color-text);
      border: 1px solid #3d3d3d;
    }

    /* ---------- Add Chart Button Styling ---------- */
    #addChartBtn,
    #createPresentation,
    #saveStateBtn {
      border: none;
      padding: 10px 20px;
      margin: 20px auto;
      display: block;
      border-radius: 5px;
      font-family: var(--font-secondary);
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
      transition: background 0.3s ease, transform 0.2s ease;
    }

    #addChartBtn {
      background: var(--color-bg-medium);
      color: var(--color-text);
    }

    #addChartBtn:hover {
      background: var(--color-bg-medium);
      transform: scale(1.05);
    }

    #createPresentation {
      background: var(--color-bg-medium);
      color: var(--color-text);
    }

    #createPresentation:hover {
      background: #007bff;
      transform: scale(1.05);
    }

    #saveStateBtn {
      background: var(--color-bg-medium);
      color: var(--color-text);
    }

    #saveStateBtn:hover {
      background: var(--color-bg-medium);
      transform: scale(1.05);
    }

    .buttons-row {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 20px;
    }

    .buttons-row button i {
      margin-right: 5px;
    }

    #openColorPicker {
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      font-family: var(--font-secondary);
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
      transition: background 0.3s ease, transform 0.2s ease;
      background: var(--color-bg-medium);
      color: var(--color-text);
      /* Optional: adjust margin if needed */
      margin: 20px auto;
    }

    #openColorPicker:hover {
      background: var(--color-bg-medium);
      transform: scale(1.05);
    }


    /* ---------- Expand Button Styling ---------- */
    .expand-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: none;
      color: var(--color-text);
      border-radius: 3px;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s ease;
      z-index: 10;
    }

    .expand-btn:hover {
      background: rgba(0, 0, 0, 0.7);
    }

    /* ---------- Global Modal for Expanded Charts ---------- */
    .modal {
      display: none;
      position: fixed;
      z-index: 1300;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.8);
    }

    .modal-content {
      background: var(--color-bg-dark);
      margin: 5% auto;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      height: 80%;
      position: relative;
    }

    .modal-content canvas,
    .modal-content svg {
      width: 80%;
      height: 80%;
      display: block;
      margin: 0 auto;
    }

    .close-modal {
      position: absolute;
      top: 10px;
      right: 20px;
      font-size: 28px;
      color: var(--color-text);
      cursor: pointer;
    }

    /* Container for each label–input pair */
    .color-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    /* Fixed width for labels so they line up */
    .color-row label {
      width: 180px;
      text-align: right;
      margin-right: 10px;
    }

    /* Positioniere das User-Info Modal rechts unter dem Account-Icon */
    #userInfoModal {
      position: fixed;
      right: 0px;
      left: auto;
      width: 250px;
      z-index: 1500;
      background: transparent;
      border: none;
      box-shadow: none;
    }

    /* Styling des Inhalts */
    .user-info {
      background: var(--color-bg-dark);
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
      padding: 15px;
    }

    /* Neue Zeile für den Mode Switch */
    .mode-switch {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 0;
    }

    .mode-switch i {
      font-size: 20px;
      color: var(--color-text);
    }

    /* Toggle Switch Styling */
    .switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 20px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked+.slider {
      background-color: #2196F3;
    }

    input:checked+.slider:before {
      transform: translateX(20px);
    }

    /* ---------- Spinner Overlay Styles ---------- */
    .spinner-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .spinner {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #3498db;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /* ---------- UI Slider ---------- */
    .ui-slider-handle {
      border-radius: 50%;
      border: 2px solid var(--color-text);
      background: var(--color-bg-medium);
      width: 20px;
      height: 20px;
    }

    .ui-widget.ui-widget-content {
      border: 1px solid #c5c5c5;
      background-color: var(--vue-color)
    }

    .ui-widget-header {
      background-color: var(--color-bg-medium)
    }

    /* ---------- Vue Treeselect Overrides ---------- */
    .vue-treeselect__control,
    .vue-treeselect__single-value,
    .vue-treeselect__placeholder,
    .vue-treeselect__multi-value-item,
    .vue-treeselect__option,
    .vue-treeselect__label,
    .vue-treeselect__value-remove {
      color: black !important;
    }

    .vue-treeselect__control {
      background-color: var(--vue-color);
      height: 36px !important;
      width: 300px !important;
      max-height: 36px !important;
      overflow: hidden !important;
    }

    .vue-treeselect__multi-value-wrapper {
      display: inline-flex !important;
      flex-wrap: nowrap !important;
      overflow-x: auto !important;
      overflow-y: hidden !important;
      white-space: nowrap !important;
      align-items: center !important;
      max-height: 36px !important;
    }

    .vue-treeselect__multi-value-item {
      white-space: nowrap !important;
      flex: 0 0 auto !important;
      background-color: var(--vue-color);
      border: 1px solid black;
    }

    .vue-treeselect--searchable:not(.vue-treeselect--disabled) .vue-treeselect__value-container {
      cursor: text;
      max-height: 50px;
      overflow-y: auto;
    }

    .vue-treeselect--has-value .vue-treeselect__multi-value {
      margin-bottom: 5px;
      height: 25px;
    }
  </style>
</head>

<body>
  <!-- Sidebar Navigation -->
  <div class="sidebar" id="sidebar">
    <span class="close-sidebar" id="closeSidebar">&times;</span>
    <nav class="main-nav">
      <ul>
        <li><a href="{{ url_for('overview') }}">Overview</a></li>
        <li><a href="{{ url_for('countries') }}">Country Deep Dive</a></li>
        <li class="active"><a href="{{ url_for('comparative') }}">Comparative View</a></li>
        <li><a href="{{ url_for('data') }}">Data</a></li>
      </ul>
    </nav>
  </div>
  <!-- Overlay for Sidebar -->
  <div class="overlay" id="overlay"></div>
  <!-- Integrated Header -->
  <header class="header">
    <!-- Burger Menu & Saved Dashboards Icon (Left) -->
    <div class="header-item header-menu" style="text-align: left;">
      <i id="burgerIcon" class="burger-icon fas fa-bars"></i>
      <select id="savedDashboardsSelect" title="Saved Dashboards">
        <option value="" disabled selected>Select Saved Dashboard</option>
        <!-- Options to be loaded dynamically -->
        <option value="dashboard1">Dashboard 1</option>
        <option value="dashboard2">Dashboard 2</option>
        <option value="dashboard3">Dashboard 3</option>
      </select>
    </div>


    <!-- Headline -->
    <div class="header-item header-headline" style="text-align: center; font-size: 12px;">
      <h1>SIQ Company Economy</h1>
    </div>
    <!-- Year Slider -->
    <div class="header-item header-yearslider" style="text-align: center;">
      <label for="yearSlider" class="filter-label" data-i18n="filter.selectYearRange"></label>
      <div id="yearSlider"></div>
      <span id="yearRangeDisplay">
        <span class="translation" data-i18n="filter.selectedYears">Selected Years</span>
        <span id="dynamicYearRange">: 2010 - 2021</span>
      </span>
    </div>
    <!-- Country Filter -->
    <div class="header-item header-countryfilter" id="vueCountrySelectContainer" style="text-align: center;">
      <!--  <label class="filter-label" data-i18n="filter.selectCountries"></label> -->
      <treeselect v-model="value" :multiple="true" :options="options" placeholder="Select countries"></treeselect>
    </div>
    <!-- Language Selector & Account Icon -->
    <div class="header-item header-right" style="display: flex; align-items: center; margin-left: auto;">
      <select id="languageSelector">
        <option value="en" data-flag="gb">English</option>
        <option value="de" data-flag="de">Deutsch</option>
        <option value="es" data-flag="es">Español</option>
        <option value="fr" data-flag="fr">Français</option>
      </select>
      <div class="header-account" style="margin-left: 10px;">
        <i id="accountIcon" class="account-icon fas fa-user"></i>
      </div>
    </div>
  </header>

  <!-- Benutzer-Info Modal (angepasst) -->
  <div id="userInfoModal" class="modal" style="display:none;">
    <div class="modal-content user-info" style="max-width:250px; padding:15px;">
      <span id="closeUserInfoModal" style="cursor:pointer; float:right;">&times;</span>
      <h2 data-i18n="account.title">Benutzerkonto</h2>
      <p data-i18n="account.usernamePlaceholder">Name: [Benutzername]</p>
      <p data-i18n="account.orgPlaceholder">Organisation: [Organisation]</p>

      <!-- Neue Zeile für den Dark/Light Mode Switch -->
      <div class="mode-switch">
        <i class="fas fa-moon"></i>
        <label class="switch">
          <input type="checkbox" id="modeToggle">
          <span class="slider"></span>
        </label>
        <i class="fas fa-sun"></i>
      </div>

      <button id="openColorPicker" data-i18n="account.openColorPicker">Farben anpassen</button>
    </div>
  </div>

  <!-- Modal for Color Settings -->
  <div id="colorModal" class="modal" style="display:none;">
    <div class="modal-content"
      style="position:relative; padding:20px; max-width:500px; margin:100px auto; background:#333; border-radius:8px; color:#e0e0e0;">
      <span id="closeColorModal"
        style="position:absolute; top:10px; right:15px; font-size:24px; cursor:pointer;">&times;</span>
      <h2>Customize Colors</h2>

      <!-- Quadrant Colors Section -->
      <h3>Quadrant Colors</h3>
      <div id="quadrantColorSettings">
        <div class="color-row">
          <label for="q1Color">Quadrant 1:</label>
          <input type="color" id="q1Color" value="#C1121F">
        </div>
        <div class="color-row">
          <label for="q2Color">Quadrant 2:</label>
          <input type="color" id="q2Color" value="#DB7C26">
        </div>
        <div class="color-row">
          <label for="q3Color">Quadrant 3:</label>
          <input type="color" id="q3Color" value="#669BBC">
        </div>
        <div class="color-row">
          <label for="q4Color">Quadrant 4:</label>
          <input type="color" id="q4Color" value="#DB7C26">
        </div>
      </div>

      <hr style="margin:20px 0; border-color: #555;">

      <!-- Dashboard Theme Colors Section -->
      <h3>Dashboard Theme</h3>
      <div id="themeSettings">
        <div class="color-row">
          <label for="color-bg">Background:</label>
          <input type="color" id="color-bg" value="#1a1a1a">
        </div>
        <div class="color-row">
          <label for="color-bg-light">Header:</label>
          <input type="color" id="color-bg-light" value="#1a1a1a">
        </div>
        <div class="color-row">
          <label for="color-bg-medium">Charts Background:</label>
          <input type="color" id="color-bg-medium" value="#333333">
        </div>
        <div class="color-row">
          <label for="color-bg-dark">Charts Grid Background:</label>
          <input type="color" id="color-bg-dark" value="#1a1a1a">
        </div>
        <div class="color-row">
          <label for="color-text">Text Color:</label>
          <input type="color" id="color-text" value="#e0e0e0">
        </div>
      </div>

      <!-- Save Colors Button -->
      <div style="text-align:center; margin-top:20px;">
        <button id="saveColorsButton" style="margin-top: 50px; padding:10px 20px; font-size:16px; cursor:pointer;">Save
          colors</button>
      </div>
    </div>
  </div>

  <!-- Saved Dashboards Dropdown -->
  <div id="savedDashboardsDropdown"
    style="position: absolute; top: 70px; left: 20px; background: var(--color-bg-light); color: var(--color-text); padding: 10px; border: 1px solid var(--color-border); border-radius: 4px; display: none; z-index: 1500;">
    You have no saved Dashboards yet.
  </div>

  <script>
    document.getElementById('languageSelector').addEventListener('change', function (e) {
      loadTranslations(e.target.value);
    });
  </script>

  <!-- Dashboard Container -->
  <div class="dashboard-container">
    <!-- Container for Multiple Chart Grids -->
    <div id="chartGridsContainer">
      <!-- Initial Chart Grid (Grid 1) with added quadrant control container -->
      <div class="charts-grid" id="grid1">
        <!-- Left Column: Quadrant Chart -->
        <div class="quadrant-chart" data-chart-type="quadrant" id="quadrantLeftContainer1">
          <button class="expand-btn" title="Expand Chart">⛶</button>
          <div id="quadrantDropdownContainer1">
            <div>
              <label for="xIndicatorSelect1">X-Axis Indicator:</label>
              <select id="xIndicatorSelect1"></select>
            </div>
            <div>
              <label for="yIndicatorSelect1">Y-Axis Indicator:</label>
              <select id="yIndicatorSelect1"></select>
            </div>
          </div>
          <div id="quadrantChartContainer1" class="quadrant-chart-container" style="height:60vh;"></div>
          <div id="quadrantControlContainer1">
            <button id="quadrantPlayButton1">&#9658;</button>
            <div id="quadrantYearScale1">
              <div id="yearMarker1">-</div>
            </div>
          </div>
        </div>
        <!-- Right Column: Line Charts -->
        <div class="line-charts" id="chartsContainer1">
          <!-- Line charts will be dynamically added here -->
        </div>
      </div>
    </div>
  </div>

  <div class="buttons-row">
    <button id="addChartBtn" data-i18n="button.addChartGrid">
      <i class="fas fa-plus-square"></i> <span class="translation">Add Chart Grid</span>
    </button>
    <button id="createPresentation" data-i18n="button.createPresentation">
      <i class="fas fa-file-powerpoint"></i> <span class="translation">Create Presentation</span>
    </button>
    <button id="saveStateBtn" data-i18n="button.saveState">
      <i class="fas fa-save"></i> <span class="translation">Save State</span>
    </button>
  </div>

  <!-- Modal for Expanded Quadrant Chart -->
  <div id="chartModal" class="modal">
    <div class="modal-content">
      <span class="close-modal">&times;</span>
      <div id="modalQuadrantDropdownContainer" style="margin-bottom: 10px; text-align: center;">
        <div style="display:inline-block; margin-right: 20px;">
          <label for="modalXIndicatorSelect">X-Axis Indicator:</label>
          <select id="modalXIndicatorSelect"></select>
        </div>
        <div style="display:inline-block;">
          <label for="modalYIndicatorSelect">Y-Axis Indicator:</label>
          <select id="modalYIndicatorSelect"></select>
        </div>
      </div>
      <svg id="modalQuadrantSvg" width="600" height="600"></svg>
      <div id="modalQuadrantControls" style="text-align: center; margin-top: 10px;">
        <button id="modalQuadrantPlayButton">&#9658;</button>
        <span id="modalYearMarker" style="margin-left: 10px;">Year: -</span>
      </div>
    </div>
  </div>

  <!-- Modal for Expanded Line Chart -->
  <div id="lineChartModal" class="modal">
    <div class="modal-content">
      <span class="close-modal" id="closeLineChartModal">&times;</span>
      <canvas id="modalLineChartCanvas"></canvas>
    </div>
  </div>

  <!-- Tooltip element -->
  <div id="tooltip"></div>

  <!-- Loading Spinner Overlay -->
  <div id="spinnerOverlay" class="spinner-overlay" style="display: none;">
    <div class="spinner"></div>
  </div>

  <!-- Scripts wrapped in DOMContentLoaded -->
  <script>
    // Helper function to fetch image as Base64 data URL
    async function getBase64Image(url) {
      try {
        const response = await fetch(url, { mode: "cors" });
        const blob = await response.blob();
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      } catch (err) {
        console.error("Error fetching image:", err);
        return null;
      }
    }

    // Helper function to append a flag image (using Base64) to a D3 selection
    async function appendFlagImage(selection, country, pos) {
      const flagUrl = `https://flagcdn.com/w80/${country.iso2Code.toLowerCase()}.png`;
      const base64Data = await getBase64Image(flagUrl);
      if (!base64Data) return;
      selection.append("svg:image")
        .attr("data-country", country.id)
        .attr("href", base64Data)
        .attr("width", 40)
        .attr("height", 25)
        .attr("x", pos.x)
        .attr("y", pos.y);
    }

    // Global variable to track which grid's quadrant chart is shown in the modal
    let currentModalGridSuffix = null;
    document.addEventListener("DOMContentLoaded", function () {
      // Sidebar Toggle Script
      const burgerIcon = document.getElementById('burgerIcon');
      const sidebar = document.getElementById('sidebar');
      const overlay = document.getElementById('overlay');
      const closeSidebar = document.getElementById('closeSidebar');
      burgerIcon.addEventListener('click', () => {
        sidebar.classList.add('active');
        overlay.classList.add('active');
      });
      closeSidebar.addEventListener('click', () => {
        sidebar.classList.remove('active');
        overlay.classList.remove('active');
      });
      overlay.addEventListener('click', () => {
        sidebar.classList.remove('active');
        overlay.classList.remove('active');
      });
      const accountIcon = document.getElementById('accountIcon');
      // Modal open/close functionality
      const colorModal = document.getElementById('colorModal');
      const closeColorModal = document.getElementById('closeColorModal');

      // Statt direkt das colorModal zu öffnen, öffne zuerst das userInfoModal
      document.getElementById('accountIcon').addEventListener('click', () => {
        document.getElementById('userInfoModal').style.display = 'block';
      });

      // Schließen des userInfoModal
      document.getElementById('closeUserInfoModal').addEventListener('click', () => {
        document.getElementById('userInfoModal').style.display = 'none';
      });

      document.getElementById('saveColorsButton').addEventListener('click', function () {
        document.getElementById('colorModal').style.display = 'none';
        updateAllCharts();
      });

      // Beim Klick auf "Farben anpassen" im userInfoModal öffnest du das colorModal
      document.getElementById('openColorPicker').addEventListener('click', () => {
        document.getElementById('userInfoModal').style.display = 'none';
        document.getElementById('colorModal').style.display = 'block';
      });

      document.getElementById('modeToggle').addEventListener('change', function () {
        if (this.checked) {
          // Light Mode: Alternative Farbwerte definieren (Beispiel)
          document.documentElement.style.setProperty('--color-bg', '#FFFFFF');
          document.documentElement.style.setProperty('--color-bg-light', '#F5F5F5');
          document.documentElement.style.setProperty('--color-bg-medium', '#E0E0E0');
          document.documentElement.style.setProperty('--color-bg-dark', '#CCCCCC');
          document.documentElement.style.setProperty('--color-text', '#000000');
          document.documentElement.style.setProperty('--vue-color', '#FFFFFF');
          // Weitere Variablen wie primary, secondary etc. können ebenfalls angepasst werden.
        } else {
          // Dark Mode: exakt die Werte, die du angegeben hast
          document.documentElement.style.setProperty('--color-bg', '#1a1a1a');
          document.documentElement.style.setProperty('--color-bg-light', '#1a1a1a');
          document.documentElement.style.setProperty('--color-bg-medium', '#333333');
          document.documentElement.style.setProperty('--color-bg-dark', '#1a1a1a');
          document.documentElement.style.setProperty('--color-primary', '#DB7C26');
          document.documentElement.style.setProperty('--color-secondary', '#C1121F');
          document.documentElement.style.setProperty('--color-tertiary', '#669BBC');
          document.documentElement.style.setProperty('--color-accent', '#228B22');
          document.documentElement.style.setProperty('--color-text', '#fdf0d5');
          document.documentElement.style.setProperty('--vue-color', '#fdf0d5');
          document.documentElement.style.setProperty('--color-border', 'rgba(255, 255, 255, 0.1)');
          document.documentElement.style.setProperty('--color-shadow', 'rgba(0, 0, 0, 0.7)');
        }
      });

      // Close modal on click of the close button or outside modal content
      closeColorModal.addEventListener('click', () => {
        colorModal.style.display = 'none';
      });
      window.addEventListener('click', (e) => {
        if (e.target === colorModal) {
          colorModal.style.display = 'none';
        }
      });

      // Attach modal close event listener for quadrant modal
      const closeBtn = document.querySelector("#chartModal .close-modal");
      if (closeBtn) {
        closeBtn.addEventListener("click", closeModal);
      } else {
        console.warn("Close modal button not found");
      }
    });
  </script>

  <!-- Dashboard & Charts Script -->
  <script>
    let countriesData = [];
    let yearRange = [2010, 2021];
    const margin = { top: 20, right: 20, bottom: 40, left: 40 };
    const indicators = [
      { value: "NY.GDP.MKTP.CD", text: "GDP (Current US$)" },
      { value: "NY.GDP.PCAP.CD", text: "GDP per Capita (Current US$)" },
      { value: "NY.GDP.MKTP.KD.ZG", text: "GDP Growth (Annual %)" },
      { value: "SP.POP.TOTL", text: "Population, Total" },
      { value: "SL.UEM.TOTL.ZS", text: "Unemployment (% of labor force)" },
      { value: "EN.ATM.CO2E.PC", text: "CO₂ Emissions (Metric tons per capita)" },
      { value: "FP.CPI.TOTL.ZG", text: "Inflation, Consumer Prices (Annual %)" },
      { value: "NE.EXP.GNFS.CD", text: "Exports of Goods and Services (Current US$)" },
      { value: "NE.IMP.GNFS.CD", text: "Imports of Goods and Services (Current US$)" },
      { value: "IT.CEL.SETS.P2", text: "Mobile Cellular Subscriptions (per 100 people)" },
      { value: "EG.ELC.ACCS.ZS", text: "Access to Electricity (% of Population)" },
      { value: "SE.XPD.TOTL.GD.ZS", text: "Government Expenditure on Education (% of GDP)" },
      { value: "SI.POV.DDAY", text: "Poverty Headcount Ratio at $1.90/day" }
    ];
    const indicatorMetadata = {
      "NY.GDP.MKTP.CD": { unit: "USD", formatter: value => "$" + new Intl.NumberFormat('en-US', { maximumFractionDigits: 0 }).format(value) },
      "NY.GDP.PCAP.CD": { unit: "USD", formatter: value => "$" + new Intl.NumberFormat('en-US', { maximumFractionDigits: 0 }).format(value) },
      "NY.GDP.MKTP.KD.ZG": { unit: "%", formatter: value => d3.format(".1f")(value) + '%' },
      "SP.POP.TOTL": { unit: "", formatter: value => new Intl.NumberFormat().format(value) },
      "SL.UEM.TOTL.ZS": { unit: "%", formatter: value => d3.format(".1f")(value) + '%' },
      "EN.ATM.CO2E.PC": { unit: "", formatter: value => new Intl.NumberFormat().format(value) },
      "FP.CPI.TOTL.ZG": { unit: "%", formatter: value => d3.format(".1f")(value) + '%' },
      "NE.EXP.GNFS.CD": { unit: "USD", formatter: value => "$" + new Intl.NumberFormat('en-US', { maximumFractionDigits: 0 }).format(value) },
      "NE.IMP.GNFS.CD": { unit: "USD", formatter: value => "$" + new Intl.NumberFormat('en-US', { maximumFractionDigits: 0 }).format(value) },
      "IT.CEL.SETS.P2": { unit: "", formatter: value => new Intl.NumberFormat().format(value) },
      "EG.ELC.ACCS.ZS": { unit: "%", formatter: value => d3.format(".1f")(value) + '%' },
      "SE.XPD.TOTL.GD.ZS": { unit: "%", formatter: value => d3.format(".1f")(value) + '%' },
      "SI.POV.DDAY": { unit: "", formatter: value => new Intl.NumberFormat().format(value) }
    };

    function getQuadrantColorsFromCSS() {
      return {
        q1: getComputedStyle(document.documentElement).getPropertyValue('--quadrant-q1').trim(),
        q2: getComputedStyle(document.documentElement).getPropertyValue('--quadrant-q2').trim(),
        q3: getComputedStyle(document.documentElement).getPropertyValue('--quadrant-q3').trim(),
        q4: getComputedStyle(document.documentElement).getPropertyValue('--quadrant-q4').trim()
      };
    }

    const quadrantColors = getQuadrantColorsFromCSS();


    function updateQuadrantColors() {
      // Re-draw or update the quadrant chart using the new quadrantColors
      // For example, if you have a function drawQuadrantChart(gridSuffix), you can call it:
      const gridSuffix = '1'; // adjust according to your context
      resetQuadrantChart(gridSuffix);
      loadQuadrantData(gridSuffix);
      drawQuadrantChart(gridSuffix);
      updateQuadrantChart(gridSuffix);
    }

    // Attach event listeners to the color inputs:
    document.getElementById('q1Color').addEventListener('input', function (e) {
      const newColor = e.target.value;
      document.documentElement.style.setProperty('--quadrant-q1', newColor);
      updateAllCharts();
    });
    document.getElementById('q2Color').addEventListener('input', function (e) {
      const newColor = e.target.value;
      document.documentElement.style.setProperty('--quadrant-q2', newColor);
      updateAllCharts();
    });
    document.getElementById('q3Color').addEventListener('input', function (e) {
      const newColor = e.target.value;
      document.documentElement.style.setProperty('--quadrant-q3', newColor);
      updateAllCharts();
    });
    document.getElementById('q4Color').addEventListener('input', function (e) {
      const newColor = e.target.value;
      document.documentElement.style.setProperty('--quadrant-q4', newColor);
      updateAllCharts();
    });
    // Update dashboard theme CSS variables dynamically
    function updateCSSVariable(variable, value) {
      document.documentElement.style.setProperty(variable, value);
    }

    document.getElementById('color-bg').addEventListener('input', (e) => {
      updateCSSVariable('--color-bg', e.target.value);
    });
    document.getElementById('color-bg-light').addEventListener('input', (e) => {
      updateCSSVariable('--color-bg-light', e.target.value);
    });
    document.getElementById('color-bg-medium').addEventListener('input', (e) => {
      updateCSSVariable('--color-bg-medium', e.target.value);
    });
    document.getElementById('color-bg-dark').addEventListener('input', (e) => {
      updateCSSVariable('--color-bg-dark', e.target.value);
    });
    document.getElementById('color-text').addEventListener('input', (e) => {
      updateCSSVariable('--color-text', e.target.value);
    });
    function getQuadrantColor(xValue, yValue, xScale, yScale) {
      const currentColors = getQuadrantColorsFromCSS();
      const xMid = (xScale.domain()[0] + xScale.domain()[1]) / 2;
      const yMid = (yScale.domain()[0] + yScale.domain()[1]) / 2;
      if (xValue >= xMid && yValue >= yMid) {
        return currentColors.q1;
      } else if (xValue < xMid && yValue >= yMid) {
        return currentColors.q2;
      } else if (xValue < xMid && yValue < yMid) {
        return currentColors.q3;
      } else {
        return currentColors.q4;
      }
    }
    const abbreviatedFormatter = d3.format(".2s");
    function getFormattedTick(value, indicator) {
      if (value === null || value === undefined || isNaN(value)) return "0";
      const meta = indicatorMetadata[indicator];
      if (meta) {
        if (meta.unit === '%') return d3.format(".1f")(value) + '%';
        else if (meta.unit === 'USD') {
          if (Math.abs(value) >= 1e12) return d3.format("$,.2s")(value);
          return "$" + new Intl.NumberFormat('en-US', { maximumFractionDigits: 0 }).format(value);
        } else {
          if (Math.abs(value) >= 1000) return abbreviatedFormatter(value);
          return value;
        }
      }
      return value;
    }
    const defaultXIndicator = "NY.GDP.PCAP.CD";
    const defaultYIndicator = "NY.GDP.MKTP.CD";
    const chartInstances = {};  // keyed by chartsContainer id
    let nextChartId = 0;
    const flagPlugin = {
      id: 'flagPlugin',
      afterDatasetsDraw(chart, args, options) {
        const { ctx } = chart;
        chart.data.datasets.forEach((dataset, i) => {
          const meta = chart.getDatasetMeta(i);
          if (!meta.hidden && meta.data.length > 0 && dataset.flagUrl) {
            const lastPoint = meta.data[meta.data.length - 1];
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.src = dataset.flagUrl;
            img.onload = function () {
              const imgWidth = 20;
              const imgHeight = 10;
              ctx.drawImage(img, lastPoint.x + 5, lastPoint.y - imgHeight / 2, imgWidth, imgHeight);
            };
          }
        });
      }
    };

    function getRandomColor(opacity = 1) {
      const r = Math.floor(Math.random() * 156) + 100;
      const g = Math.floor(Math.random() * 156) + 100;
      const b = Math.floor(Math.random() * 156) + 100;
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
    function filterDataByYears(data, startYear, endYear) {
      const filtered = { years: [], values: [] };
      for (let i = 0; i < data.years.length; i++) {
        const yr = parseInt(data.years[i]);
        if (yr >= startYear && yr <= endYear) {
          filtered.years.push(data.years[i]);
          filtered.values.push(data.values[i]);
        }
      }
      return filtered;
    }
    async function fetchIndicatorData(country, indicator) {
      const url = `https://api.worldbank.org/v2/country/${country}/indicator/${indicator}?format=json&per_page=1000`;
      try {
        const response = await fetch(url);
        const json = await response.json();
        if (!json || json.length < 2) return { years: [], values: [] };
        const rawData = json[1].filter(d => d.value !== null);
        rawData.sort((a, b) => parseInt(a.date) - parseInt(b.date));
        const years = rawData.map(d => d.date);
        const values = rawData.map(d => d.value);
        return { years, values };
      } catch (error) {
        console.error("Error fetching data for", country, error);
        return { years: [], values: [] };
      }
    }
    async function getChartDataForIndicator(indicator, gridSuffix) {
      const selectedCountries = window.selectedCountries || [];
      const state = getQuadrantState(gridSuffix);
      const datasets = await Promise.all(selectedCountries.map(async (countryIso3) => {
        const countryObj = countriesData.find(c => c.id === countryIso3);
        if (!countryObj) {
          return null;
        }
        const completeData = await fetchIndicatorData(countryIso3, indicator);
        const filteredData = filterDataByYears(completeData, yearRange[0], yearRange[1]);
        let lineColor = '#CCCCCC';
        if (state.data.length > 0) {
          const countryData = state.data.find(d => d.country.id === countryIso3);
          if (countryData && countryData.data.length > 0) {
            const endYearData = countryData.data[countryData.data.length - 1];
            lineColor = getQuadrantColor(
              endYearData.x,
              endYearData.y,
              state.xScale,
              state.yScale
            );
          }
        }
        return {
          label: countryObj.name,
          data: filteredData.values,
          borderColor: lineColor,
          backgroundColor: lineColor + '33',
          fill: false,
          tension: 0.1,
          flagUrl: `https://flagcdn.com/w80/${countryObj.iso2Code.toLowerCase()}.png`,
          years: filteredData.years
        };
      }));
      const validDatasets = datasets.filter(d => d !== null);
      return { chartLabels: validDatasets[0]?.years || [], datasets: validDatasets };
    }
    async function updateChartInstance(chartObj, containerId) {
      const gridSuffix = containerId.replace('chartsContainer', '');
      const indicator = chartObj.indicatorSelect.value;
      const data = await getChartDataForIndicator(indicator, gridSuffix);
      if (!data) return;
      const selectedInd = indicators.find(ind => ind.value === indicator);
      chartObj.chart.options.plugins.title.text = selectedInd ? selectedInd.text : "";
      chartObj.chart.data.labels = data.chartLabels;
      chartObj.chart.data.datasets = data.datasets;
      chartObj.chart.options.scales.y.ticks.callback = function (value) {
        return getFormattedTick(value, indicator);
      };
      chartObj.chart.update();
    }
    function isQuadrantReady(gridSuffix) {
      const state = getQuadrantState(gridSuffix);
      return state.data && state.data.length > 0 && state.xScale && state.yScale;
    }
    async function updateAllCharts() {
      const gridContainer = document.getElementById("chartGridsContainer");
      const grids = gridContainer.querySelectorAll(".charts-grid");
      for (const grid of grids) {
        const gridSuffix = grid.id.replace('grid', '');
        await loadQuadrantData(gridSuffix);
        while (!isQuadrantReady(gridSuffix)) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      for (const gridId in chartInstances) {
        const instances = chartInstances[gridId];
        for (const chartObj of instances) {
          await updateChartInstance(chartObj, gridId);
        }
      }
    }
    function getAdjustedFlagPosition(lastDatum, xScale, yScale, width, height) {
      const flagWidth = 40, flagHeight = 25;
      const dataXMid = (xScale.domain()[0] + xScale.domain()[1]) / 2;
      const dataYMid = (yScale.domain()[0] + yScale.domain()[1]) / 2;
      const xMidScreen = xScale(dataXMid);
      const yMidScreen = yScale(dataYMid);
      let quadrantIndex;
      if (lastDatum.x >= dataXMid && lastDatum.y >= dataYMid) {
        quadrantIndex = 1;
      } else if (lastDatum.x < dataXMid && lastDatum.y >= dataYMid) {
        quadrantIndex = 2;
      } else if (lastDatum.x < dataXMid && lastDatum.y < dataYMid) {
        quadrantIndex = 3;
      } else {
        quadrantIndex = 4;
      }
      let qMinX, qMaxX, qMinY, qMaxY;
      switch (quadrantIndex) {
        case 1:
          qMinX = xMidScreen;
          qMaxX = width;
          qMinY = 0;
          qMaxY = yMidScreen;
          break;
        case 2:
          qMinX = 0;
          qMaxX = xMidScreen;
          qMinY = 0;
          qMaxY = yMidScreen;
          break;
        case 3:
          qMinX = 0;
          qMaxX = xMidScreen;
          qMinY = yMidScreen;
          qMaxY = height;
          break;
        case 4:
          qMinX = xMidScreen;
          qMaxX = width;
          qMinY = yMidScreen;
          qMaxY = height;
          break;
      }
      let desiredX = xScale(lastDatum.x) + 5;
      let desiredY = yScale(lastDatum.y) - 12;
      let finalX = Math.min(Math.max(desiredX, qMinX), qMaxX - flagWidth);
      let finalY = Math.min(Math.max(desiredY, qMinY), qMaxY - flagHeight);
      return { x: finalX, y: finalY };
    }
    async function redrawQuadrantChartInModal(gridSuffix) {
      const modalSvg = d3.select("#modalQuadrantSvg");
      modalSvg.selectAll("*").remove();
      const modalWidth = +modalSvg.attr("width"),
        modalHeight = +modalSvg.attr("height");
      const modalMargin = { top: 20, right: 20, bottom: 40, left: 40 };
      const width = modalWidth - modalMargin.left - modalMargin.right;
      const height = modalHeight - modalMargin.top - modalMargin.bottom;
      const g = modalSvg.append("g")
        .attr("transform", `translate(${modalMargin.left},${modalMargin.top})`);
      const state = getQuadrantState(gridSuffix);
      if (!state.data || state.data.length === 0) return;
      const xIndicator = document.getElementById("modalXIndicatorSelect").value || defaultXIndicator;
      const yIndicator = document.getElementById("modalYIndicatorSelect").value || defaultYIndicator;
      const allPoints = state.data.flatMap(d => d.data);
      const xScale = d3.scaleLinear().domain(d3.extent(allPoints, d => d.x)).nice().range([0, width]);
      const yScale = d3.scaleLinear().domain(d3.extent(allPoints, d => d.y)).nice().range([height, 0]);
      const xMid = xScale((xScale.domain()[0] + xScale.domain()[1]) / 2);
      const yMid = yScale((yScale.domain()[0] + yScale.domain()[1]) / 2);

      // Hole die aktuellen Quadrantenfarben dynamisch:
      const quadrantColors = getQuadrantColorsFromCSS();

      // Definiere die Quadranten mithilfe der aktuellen Farben:
      const quadrants = [
        { x: 0, y: 0, width: xMid, height: yMid, fill: quadrantColors.q2 }, // Top Left
        { x: xMid, y: 0, width: width - xMid, height: yMid, fill: quadrantColors.q1 }, // Top Right
        { x: 0, y: yMid, width: xMid, height: height - yMid, fill: quadrantColors.q3 }, // Bottom Left
        { x: xMid, y: yMid, width: width - xMid, height: height - yMid, fill: quadrantColors.q4 } // Bottom Right
      ];

      quadrants.forEach(quadrant => {
        g.append("rect")
          .attr("x", quadrant.x)
          .attr("y", quadrant.y)
          .attr("width", quadrant.width)
          .attr("height", quadrant.height)
          .attr("fill", quadrant.fill);
      });

      const xAxis = d3.axisBottom(xScale).tickFormat(d => {
        let formatted = d3.format(".2s")(d);
        if (indicatorMetadata[xIndicator] && indicatorMetadata[xIndicator].unit === '%') {
          formatted += '%';
        }
        return formatted;
      });
      const yAxis = d3.axisLeft(yScale).tickFormat(d => {
        let formatted = d3.format(".2s")(d);
        if (indicatorMetadata[yIndicator] && indicatorMetadata[yIndicator].unit === '%') {
          formatted += '%';
        }
        return formatted;
      });

      g.append("g")
        .attr("class", "axis x-axis")
        .attr("transform", `translate(0,${height})`)
        .call(xAxis);
      g.append("g")
        .attr("class", "axis y-axis")
        .call(yAxis);
      g.append("line")
        .attr("x1", xMid)
        .attr("x2", xMid)
        .attr("y1", 0)
        .attr("y2", height)
        .attr("stroke", "#ccc")
        .attr("stroke-dasharray", "4,4");
      g.append("line")
        .attr("y1", yMid)
        .attr("y2", yMid)
        .attr("x1", 0)
        .attr("x2", width)
        .attr("stroke", "#ccc")
        .attr("stroke-dasharray", "4,4");

      state.data.forEach(d => {
        const datum = d.data[d.data.length - 1];
        if (datum) {
          g.append("circle")
            .attr("cx", xScale(datum.x))
            .attr("cy", yScale(datum.y))
            .attr("r", 5)
            .attr("fill", getQuadrantColor(datum.x, datum.y, xScale, yScale));
          let pos = getAdjustedFlagPosition(datum, xScale, yScale, width, height);
          appendFlagImage(g, d.country, pos);
        }
      });
    }
    function openModal(container) {
      if (container.getAttribute("data-chart-type") === "quadrant") {
        let gridSuffix = container.id.replace("quadrantLeftContainer", "");
        currentModalGridSuffix = gridSuffix;
        const modal = document.getElementById("chartModal");
        modal.style.display = "block";
        populateModalDropdowns();
        const modalContent = modal.querySelector(".modal-content");
        const newWidth = modalContent.clientWidth * 0.8;
        const newHeight = modalContent.clientHeight * 0.8;
        const modalSvg = document.getElementById("modalQuadrantSvg");
        modalSvg.setAttribute("width", newWidth);
        modalSvg.setAttribute("height", newHeight);
        redrawQuadrantChartInModal(gridSuffix);
      }
    }
    function closeModal() {
      document.getElementById("chartModal").style.display = "none";
    }
    document.addEventListener("click", function (e) {
      if (e.target && e.target.classList.contains("expand-btn")) {
        let container = e.target.closest(".quadrant-chart");
        if (container) {
          openModal(container);
        }
      }
    });
    window.addEventListener("click", function (e) {
      const modal = document.getElementById("chartModal");
      if (e.target === modal) {
        closeModal();
      }
    });
    function openLineChartModal(chartInstance) {
      const modal = document.getElementById("lineChartModal");
      modal.style.display = "block";
      requestAnimationFrame(() => {
        const modalContent = modal.querySelector(".modal-content");
        const canvas = document.getElementById("modalLineChartCanvas");
        const canvasWidth = modalContent.clientWidth * 0.8;
        const canvasHeight = modalContent.clientHeight * 0.8;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext("2d");
        const config = {
          type: chartInstance.config.type,
          data: JSON.parse(JSON.stringify(chartInstance.config.data)),
          options: Object.assign({}, chartInstance.config.options, {
            responsive: false,
            maintainAspectRatio: false,
            animation: false
          }),
          plugins: [flagPlugin]
        };
        if (canvas.chartInstance) {
          canvas.chartInstance.destroy();
        }
        canvas.chartInstance = new Chart(ctx, config);
      });
    }
    document.getElementById("closeLineChartModal").addEventListener("click", () => {
      const modal = document.getElementById("lineChartModal");
      modal.style.display = "none";
      const modalCanvas = document.getElementById("modalLineChartCanvas");
      if (modalCanvas.chartInstance) {
        modalCanvas.chartInstance.destroy();
        modalCanvas.chartInstance = null;
      }
    });
    window.addEventListener("click", function (e) {
      const modal = document.getElementById("lineChartModal");
      if (e.target === modal) {
        modal.style.display = "none";
        const modalCanvas = document.getElementById("modalLineChartCanvas");
        if (modalCanvas.chartInstance) {
          modalCanvas.chartInstance.destroy();
          modalCanvas.chartInstance = null;
        }
      }
    });
    async function createNewChartInstance(defaultIndicator, containerId, axis) {
      const gridSuffix = containerId.replace('chartsContainer', '');
      await getChartDataForIndicator(defaultIndicator, gridSuffix);
      const chartsContainer = document.getElementById(containerId);
      const chartWrapper = document.createElement("div");
      chartWrapper.classList.add("line-chart-wrapper");

      const expandBtn = document.createElement("button");
      expandBtn.className = "expand-btn";
      expandBtn.title = "Expand Chart";
      expandBtn.innerHTML = "⛶";
      chartWrapper.appendChild(expandBtn);

      const indicatorSelect = document.createElement("select");
      indicatorSelect.classList.add("indicatorSelect");
      indicators.forEach(ind => {
        const option = document.createElement("option");
        option.value = ind.value;
        option.textContent = ind.text;
        indicatorSelect.appendChild(option);
      });
      indicatorSelect.value = defaultIndicator || indicators[0].value;

      indicatorSelect.addEventListener("change", () => {
        // Update the line chart instance
        const instance = chartInstances[containerId].find(obj => obj.indicatorSelect === indicatorSelect);
        if (instance) {
          updateChartInstance(instance, containerId);
        }
        // Sync the corresponding quadrant axis select based on the provided axis parameter.
        const quadSelect = document.getElementById(`${axis}IndicatorSelect${gridSuffix}`);
        if (quadSelect) {
          quadSelect.value = indicatorSelect.value;
          loadQuadrantData(gridSuffix);
          updateAllCharts();
        }
      });

      chartWrapper.appendChild(indicatorSelect);

      const canvas = document.createElement("canvas");
      canvas.id = `chartCanvas${nextChartId++}`;
      canvas.classList.add("chart-canvas");
      chartWrapper.appendChild(canvas);
      chartsContainer.appendChild(chartWrapper);

      const ctx = canvas.getContext("2d");
      const newChart = new Chart(ctx, {
        type: 'line',
        data: { labels: [], datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { right: 70 } },
          plugins: { title: { display: false } },
          scales: {
            x: { title: { display: true, text: 'Year' } },
            y: { title: { display: true, text: 'Value' }, ticks: { callback: value => value } }
          }
        },
        plugins: [flagPlugin]
      });

      expandBtn.addEventListener("click", () => {
        openLineChartModal(newChart);
      });

      if (!chartInstances[containerId]) chartInstances[containerId] = [];
      chartInstances[containerId].push({ chart: newChart, indicatorSelect: indicatorSelect });
    }
    let quadrantStates = {};
    function getQuadrantState(gridSuffix) {
      if (!quadrantStates[gridSuffix]) {
        quadrantStates[gridSuffix] = {
          data: [],
          years: [],
          currentYearIndex: 0,
          svgSelection: null,
          width: 0,
          height: 0,
          history: {}
        };
      }
      return quadrantStates[gridSuffix];
    }
    function resetQuadrantChart(gridSuffix) {
      const state = getQuadrantState(gridSuffix);
      const container = document.getElementById("quadrantChartContainer" + gridSuffix);
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      d3.select("#quadrantChartContainer" + gridSuffix).selectAll("*").remove();
      state.svgSelection = d3.select("#quadrantChartContainer" + gridSuffix)
        .append("svg")
        .attr("width", containerWidth)
        .attr("height", containerHeight)
        .append("g")
        .attr("transform", `translate(${margin.top},${margin.left})`);
      state.width = containerWidth - margin.top - margin.right;
      state.height = containerHeight - margin.top - margin.bottom;
    }
    function getSelectedQuadrantIndicators(gridSuffix) {
      const xIndicator = document.getElementById("xIndicatorSelect" + gridSuffix).value;
      const yIndicator = document.getElementById("yIndicatorSelect" + gridSuffix).value;
      return { xIndicator, yIndicator };
    }
    async function loadQuadrantData(gridSuffix) {
      resetQuadrantChart(gridSuffix);
      const state = getQuadrantState(gridSuffix);
      const selectedCountryIds = window.selectedCountries;
      if (!selectedCountryIds || selectedCountryIds.length === 0) return;
      const { xIndicator, yIndicator } = getSelectedQuadrantIndicators(gridSuffix);
      state.data = [];
      await Promise.all(selectedCountryIds.map(async countryId => {
        const countryObj = countriesData.find(c => c.id === countryId) ||
          { id: countryId, name: countryId, iso2Code: countryId.substring(0, 2).toLowerCase() };
        const xData = await fetchIndicatorData(countryId, xIndicator);
        const yData = await fetchIndicatorData(countryId, yIndicator);
        const xMap = new Map();
        xData.years.forEach((yr, i) => { xMap.set(yr, xData.values[i]); });
        const yMap = new Map();
        yData.years.forEach((yr, i) => { yMap.set(yr, yData.values[i]); });
        const commonYears = xData.years.filter(yr => yMap.has(yr)).sort((a, b) => a - b);
        const filteredYears = commonYears.filter(yr => +yr >= yearRange[0] && +yr <= yearRange[1]);
        const dataPoints = filteredYears.map(yr => ({ year: +yr, x: +xMap.get(yr), y: +yMap.get(yr) }));
        state.data.push({ country: countryObj, data: dataPoints });
      }));
      if (state.data.length > 0) {
        const allYears = state.data.map(d => d.data.map(p => p.year));
        state.years = allYears.reduce((acc, curr) => acc.filter(y => curr.includes(y)));
        state.years.sort((a, b) => a - b);
      }
      state.currentYearIndex = state.years.length - 1;
      state.history = {};
      drawQuadrantChart(gridSuffix);
      updateYearMarker(gridSuffix);
      updateQuadrantChart(gridSuffix);
    }
    function drawQuadrantChart(gridSuffix) {
      const state = getQuadrantState(gridSuffix);
      const { xIndicator, yIndicator } = getSelectedQuadrantIndicators(gridSuffix);
      const allPoints = state.data.flatMap(d => d.data);
      const xScale = d3.scaleLinear()
        .domain(d3.extent(allPoints, d => d.x)).nice()
        .range([0, state.width]);
      const yScale = d3.scaleLinear()
        .domain(d3.extent(allPoints, d => d.y)).nice()
        .range([state.height, 0]);
      state.xScale = xScale;
      state.yScale = yScale;
      const xMid = xScale((xScale.domain()[0] + xScale.domain()[1]) / 2);
      const yMid = yScale((yScale.domain()[0] + yScale.domain()[1]) / 2);

      // Aktualisiere die Quadrantenfarben dynamisch:
      const quadrantColors = getQuadrantColorsFromCSS();

      // Definiere die Quadranten mithilfe der aktuell geladenen Farben:
      const quadrants = [
        { x: 0, y: 0, width: xMid, height: yMid, fill: quadrantColors.q2 }, // Top Left
        { x: xMid, y: 0, width: state.width - xMid, height: yMid, fill: quadrantColors.q1 }, // Top Right
        { x: 0, y: yMid, width: xMid, height: state.height - yMid, fill: quadrantColors.q3 }, // Bottom Left
        { x: xMid, y: yMid, width: state.width - xMid, height: state.height - yMid, fill: quadrantColors.q4 } // Bottom Right
      ];

      // Hintergrund-Layer für die Quadranten erstellen
      const backgroundLayer = state.svgSelection.append("g").attr("id", "background-layer");
      quadrants.forEach(quadrant => {
        backgroundLayer.append("rect")
          .attr("x", quadrant.x)
          .attr("y", quadrant.y)
          .attr("width", quadrant.width)
          .attr("height", quadrant.height)
          .attr("fill", quadrant.fill);
      });

      // Axen und Mittellinien zeichnen
      state.svgSelection.append("g")
        .attr("class", "axis x-axis")
        .attr("transform", `translate(0,${state.height})`)
        .call(d3.axisBottom(xScale).tickFormat(d => {
          let formatted = d3.format(".2s")(d);
          if (indicatorMetadata[xIndicator] && indicatorMetadata[xIndicator].unit === '%') {
            formatted += '%';
          }
          return formatted;
        }));
      state.svgSelection.append("g")
        .attr("class", "axis y-axis")
        .call(d3.axisLeft(yScale).tickFormat(d => {
          let formatted = d3.format(".2s")(d);
          if (indicatorMetadata[yIndicator] && indicatorMetadata[yIndicator].unit === '%') {
            formatted += '%';
          }
          return formatted;
        }));
      state.svgSelection.append("line")
        .attr("x1", xScale((xScale.domain()[0] + xScale.domain()[1]) / 2))
        .attr("x2", xScale((xScale.domain()[0] + xScale.domain()[1]) / 2))
        .attr("y1", 0)
        .attr("y2", state.height)
        .attr("stroke", "#ccc")
        .attr("stroke-dasharray", "4,4");
      state.svgSelection.append("line")
        .attr("y1", yScale((yScale.domain()[0] + yScale.domain()[1]) / 2))
        .attr("y2", yScale((yScale.domain()[0] + yScale.domain()[1]) / 2))
        .attr("x1", 0)
        .attr("x2", state.width)
        .attr("stroke", "#ccc")
        .attr("stroke-dasharray", "4,4");

      // Icons-Layer hinzufügen
      const iconsLayer = state.svgSelection.append("g").attr("id", "icons-layer");
      const iconSize = 50;
      const padding = 5;
      const icons = [
        {
          quadrantIndex: 0, iconClass: "fas fa-adjust",      // Top Left
          x: quadrants[0].x + padding,
          y: quadrants[0].y + padding
        },
        {
          quadrantIndex: 1, iconClass: "fas fa-fire",        // Top Right
          x: quadrants[1].x + quadrants[1].width - iconSize - padding,
          y: quadrants[1].y + padding
        },
        {
          quadrantIndex: 2, iconClass: "fas fa-snowflake",    // Bottom Left
          x: quadrants[2].x + padding,
          y: quadrants[2].y + quadrants[2].height - iconSize - padding
        },
        {
          quadrantIndex: 3, iconClass: "fas fa-adjust",       // Bottom Right
          x: quadrants[3].x + quadrants[3].width - iconSize - padding,
          y: quadrants[3].y + quadrants[3].height - iconSize - padding
        }
      ];

      icons.forEach(item => {
        iconsLayer.append("foreignObject")
          .attr("x", item.x)
          .attr("y", item.y)
          .attr("width", iconSize)
          .attr("height", iconSize)
          .html(`
        <div xmlns="http://www.w3.org/1999/xhtml" style="font-size:45px; color:#FFFFFF; opacity:0.5;">
          <i class="${item.iconClass}"></i>
        </div>
      `);
      });

      // Länder-Elemente (Linien und Kreise) zeichnen
      state.data.forEach(d => {
        state.history[d.country.id] = [];
        const g = state.svgSelection.append("g")
          .attr("class", "country-group")
          .attr("id", "group-" + d.country.id + gridSuffix);
        g.append("path")
          .attr("class", "country-path")
          .attr("id", "path-" + d.country.id + gridSuffix)
          .attr("fill", "none")
          .attr("stroke", getRandomColor(1))
          .attr("stroke-width", 2);
        g.append("circle")
          .attr("class", "country-circle")
          .attr("id", "circle-" + d.country.id + gridSuffix)
          .attr("r", 5)
          .attr("fill", getRandomColor(1));
      });
    }

    function updateQuadrantChart(gridSuffix) {
      const state = getQuadrantState(gridSuffix);
      if (state.currentYearIndex >= state.years.length) return;
      const year = state.years[state.currentYearIndex];
      const { xIndicator, yIndicator } = getSelectedQuadrantIndicators(gridSuffix);
      state.data.forEach(d => {
        const datum = d.data.find(p => p.year === year);
        if (datum) {
          state.history[d.country.id].push(datum);
          const circleSelection = d3.select("#circle-" + d.country.id + gridSuffix);
          circleSelection
            .on("mouseover", function (event) {
              d3.select("#tooltip").style("opacity", 1)
                .html(`Year: ${datum.year}<br>${xIndicator}: ${datum.x}<br>${yIndicator}: ${datum.y}`);
            })
            .on("mousemove", function (event) {
              d3.select("#tooltip").style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY + 10) + "px");
            })
            .on("mouseout", function () {
              d3.select("#tooltip").style("opacity", 0);
            })
            .transition()
            .duration(500)
            .attr("cx", state.xScale(datum.x))
            .attr("cy", state.yScale(datum.y))
            .attr("fill", getQuadrantColor(datum.x, datum.y, state.xScale, state.yScale))
            .on("end", function () {
              d3.select(this.parentNode).select("image").remove();
              let pos = getAdjustedFlagPosition(datum, state.xScale, state.yScale, state.width, state.height);
              appendFlagImage(d3.select(this.parentNode), d.country, pos);
            });
          const lineGenerator = d3.line()
            .x(d => state.xScale(d.x))
            .y(d => state.yScale(d.y));
          d3.select("#path-" + d.country.id + gridSuffix)
            .attr("d", lineGenerator(state.history[d.country.id]));
        }
      });
      updateYearMarker(gridSuffix);
    }
    function updateYearMarker(gridSuffix) {
      const state = getQuadrantState(gridSuffix);
      if (state.years.length === 0) return;
      const year = state.currentYearIndex < state.years.length ? state.years[state.currentYearIndex] : state.years[state.years.length - 1];
      const marker = document.getElementById("yearMarker" + gridSuffix);
      if (!marker) {
        console.warn("yearMarker element for gridSuffix", gridSuffix, "not found.");
        return;
      }
      marker.textContent = year;
      const scaleContainer = document.getElementById("quadrantYearScale" + gridSuffix);
      if (!scaleContainer) return;
      const containerWidth = scaleContainer.clientWidth;
      const markerWidth = marker.clientWidth;
      const minYear = state.years[0];
      const maxYear = state.years[state.years.length - 1];
      const pos = ((year - minYear) / (maxYear - minYear)) * (containerWidth - markerWidth);
      marker.style.left = pos + "px";
    }
    function updateModalQuadrantChart() {
      const gridSuffix = currentModalGridSuffix;
      const state = getQuadrantState(gridSuffix);
      if (state.currentYearIndex >= state.years.length) return;
      const year = state.years[state.currentYearIndex];
      const { xIndicator, yIndicator } = getSelectedQuadrantIndicators(gridSuffix);
      document.getElementById("modalYearMarker").textContent = "Year: " + year;

      state.data.forEach(d => {
        const datum = d.data.find(p => p.year === year);
        if (datum) {
          state.history[d.country.id] = state.history[d.country.id] || [];
          state.history[d.country.id].push(datum);
        }
      });

      const modalSvg = d3.select("#modalQuadrantSvg");
      modalSvg.selectAll("*").remove();
      const modalWidth = +modalSvg.attr("width");
      const modalHeight = +modalSvg.attr("height");
      const modalMargin = { top: 20, right: 20, bottom: 40, left: 40 };
      const width = modalWidth - modalMargin.left - modalMargin.right;
      const height = modalHeight - modalMargin.top - modalMargin.bottom;
      const g = modalSvg.append("g")
        .attr("transform", `translate(${modalMargin.left},${modalMargin.top})`);
      const allPoints = state.data.flatMap(d => d.data);
      const xScale = d3.scaleLinear().domain(d3.extent(allPoints, d => d.x)).nice().range([0, width]);
      const yScale = d3.scaleLinear().domain(d3.extent(allPoints, d => d.y)).nice().range([height, 0]);
      const xMid = xScale((xScale.domain()[0] + xScale.domain()[1]) / 2);
      const yMid = yScale((yScale.domain()[0] + yScale.domain()[1]) / 2);

      // Hole die aktuellen Quadrantenfarben dynamisch aus den CSS-Variablen:
      const quadrantColors = getQuadrantColorsFromCSS();

      // Definiere die Quadranten mithilfe der aktuellen Farben:
      const quadrants = [
        { x: 0, y: 0, width: xMid, height: yMid, fill: quadrantColors.q2 }, // Top Left
        { x: xMid, y: 0, width: width - xMid, height: yMid, fill: quadrantColors.q1 }, // Top Right
        { x: 0, y: yMid, width: xMid, height: height - yMid, fill: quadrantColors.q3 }, // Bottom Left
        { x: xMid, y: yMid, width: width - xMid, height: height - yMid, fill: quadrantColors.q4 } // Bottom Right
      ];

      quadrants.forEach(q => {
        g.append("rect")
          .attr("x", q.x)
          .attr("y", q.y)
          .attr("width", q.width)
          .attr("height", q.height)
          .attr("fill", q.fill);
      });

      g.append("line")
        .attr("x1", xMid)
        .attr("x2", xMid)
        .attr("y1", 0)
        .attr("y2", height)
        .attr("stroke", "#ccc")
        .attr("stroke-dasharray", "4,4");
      g.append("line")
        .attr("y1", yMid)
        .attr("y2", yMid)
        .attr("x1", 0)
        .attr("x2", width)
        .attr("stroke", "#ccc")
        .attr("stroke-dasharray", "4,4");

      state.data.forEach(d => {
        const history = state.history[d.country.id];
        if (!history || history.length === 0) return;
        const lastDatum = history[history.length - 1];
        let circle = g.select(`circle[data-country='${d.country.id}']`);
        if (circle.empty()) {
          circle = g.append("circle")
            .attr("data-country", d.country.id)
            .attr("r", 5)
            .attr("cx", xScale(lastDatum.x))
            .attr("cy", yScale(lastDatum.y))
            .attr("fill", getQuadrantColor(lastDatum.x, lastDatum.y, xScale, yScale));
          let pos = getAdjustedFlagPosition(lastDatum, xScale, yScale, width, height);
          appendFlagImage(g, d.country, pos);
        } else {
          circle.transition()
            .duration(500)
            .attr("cx", xScale(lastDatum.x))
            .attr("cy", yScale(lastDatum.y))
            .attr("fill", getQuadrantColor(lastDatum.x, lastDatum.y, xScale, yScale))
            .on("end", function () {
              g.select(`image[data-country='${d.country.id}']`).remove();
              let pos = getAdjustedFlagPosition(lastDatum, xScale, yScale, width, height);
              appendFlagImage(g, d.country, pos);
            });
        }
        const lineGenerator = d3.line()
          .x(d => xScale(d.x))
          .y(d => yScale(d.y));
        let path = g.select(`path[data-country='${d.country.id}']`);
        if (path.empty()) {
          path = g.append("path")
            .attr("data-country", d.country.id)
            .attr("fill", "none")
            .attr("stroke", getRandomColor(1))
            .attr("stroke-width", 2);
        }
        path.attr("d", lineGenerator(history));
      });
    }

    function playQuadrantChart(gridSuffix) {
      const state = getQuadrantState(gridSuffix);
      state.currentYearIndex = 0;
      state.data.forEach(d => {
        state.history[d.country.id] = [];
        d3.select("#path-" + d.country.id + gridSuffix).attr("d", null);
        d3.select("#circle-" + d.country.id + gridSuffix)
          .attr("cx", null)
          .attr("cy", null);
        d3.select("#group-" + d.country.id + gridSuffix).selectAll("image").remove();
      });
      updateYearMarker(gridSuffix);
      const interval = d3.interval(() => {
        if (state.currentYearIndex >= state.years.length) {
          interval.stop();
          return;
        }
        updateQuadrantChart(gridSuffix);
        state.currentYearIndex++;
      }, 500);
    }
    function playModalQuadrantChart() {
      const gridSuffix = currentModalGridSuffix;
      const state = getQuadrantState(gridSuffix);
      state.currentYearIndex = 0;
      state.data.forEach(d => {
        state.history[d.country.id] = [];
      });
      const interval = d3.interval(() => {
        if (state.currentYearIndex >= state.years.length) {
          interval.stop();
          return;
        }
        updateModalQuadrantChart();
        state.currentYearIndex++;
      }, 500);
    }
    document.getElementById("modalQuadrantPlayButton").addEventListener("click", playModalQuadrantChart);
    async function createNewChartGrid() {
      const gridContainer = document.getElementById("chartGridsContainer");
      const gridCount = gridContainer.querySelectorAll('.charts-grid').length + 1;
      const newGrid = document.createElement("div");
      newGrid.className = "charts-grid";
      newGrid.id = `grid${gridCount}`;

      // Create a delete button and position it in the top right corner
      const deleteBtn = document.createElement("button");
      deleteBtn.className = "delete-grid-btn";
      deleteBtn.textContent = "✖"; // or use an icon
      // Style the button (you can also add these rules to your CSS file)
      deleteBtn.style.position = "absolute";
      deleteBtn.style.top = "5px";
      deleteBtn.style.right = "5px";
      deleteBtn.style.border = "none";
      deleteBtn.style.background = "transparent";
      deleteBtn.style.color = "var(--color-text)";
      deleteBtn.style.cursor = "pointer";
      // Attach the click event to remove the grid
      deleteBtn.addEventListener("click", () => {
        newGrid.remove();
        // Optionally update state or localStorage here if needed.
      });
      newGrid.appendChild(deleteBtn);

      // Create quadrant and line charts containers as before
      const quadrantDiv = document.createElement("div");
      quadrantDiv.className = "quadrant-chart";
      quadrantDiv.setAttribute("data-chart-type", "quadrant");
      quadrantDiv.id = `quadrantLeftContainer${gridCount}`;
      quadrantDiv.innerHTML = `
    <button class="expand-btn" title="Expand Chart">⛶</button>
    <div id="quadrantDropdownContainer${gridCount}">
      <div>
        <label for="xIndicatorSelect${gridCount}">X-Axis Indicator:</label>
        <select id="xIndicatorSelect${gridCount}"></select>
      </div>
      <div>
        <label for="yIndicatorSelect${gridCount}">Y-Axis Indicator:</label>
        <select id="yIndicatorSelect${gridCount}"></select>
      </div>
    </div>
    <div id="quadrantChartContainer${gridCount}" class="quadrant-chart-container" style="height:60vh;"></div>
    <div id="quadrantControlContainer${gridCount}">
      <button id="quadrantPlayButton${gridCount}">&#9658;</button>
      <div id="quadrantYearScale${gridCount}">
        <div id="yearMarker${gridCount}">-</div>
      </div>
    </div>
  `;
      const lineChartsDiv = document.createElement("div");
      lineChartsDiv.className = "line-charts";
      lineChartsDiv.id = `chartsContainer${gridCount}`;
      lineChartsDiv.innerHTML = `<!-- Line charts will be dynamically added here -->`;

      newGrid.appendChild(quadrantDiv);
      newGrid.appendChild(lineChartsDiv);
      gridContainer.appendChild(newGrid);

      populateQuadrantIndicatorDropdownsForGrid(gridCount);
      document.getElementById("quadrantPlayButton" + gridCount).addEventListener("click", () => {
        playQuadrantChart(gridCount);
      });
      createNewChartInstance(defaultXIndicator, `chartsContainer${gridCount}`, "x");
      createNewChartInstance(defaultYIndicator, `chartsContainer${gridCount}`, "y");
      await loadQuadrantData(gridCount);
    }
    document.getElementById("addChartBtn").addEventListener("click", () => {
      createNewChartGrid();
      updateAllCharts();
    });
    function showSpinner() {
      document.getElementById("spinnerOverlay").style.display = "flex";
    }
    function hideSpinner() {
      document.getElementById("spinnerOverlay").style.display = "none";
    }
    function restoreLineChartIndicators(savedGrids) {
      for (const gridSuffix in savedGrids) {
        const gridState = savedGrids[gridSuffix];
        if (gridState.lineChartIndicators) {
          const chartsContainer = document.getElementById("chartsContainer" + gridSuffix);
          if (chartsContainer) {
            const selects = chartsContainer.querySelectorAll(".indicatorSelect");
            selects.forEach((sel, index) => {
              if (gridState.lineChartIndicators[index]) {
                sel.value = gridState.lineChartIndicators[index];
              }
            });
          }
        }
      }
    }
    // Reordered initialization for grid 1:
    document.addEventListener("DOMContentLoaded", async () => {
      showSpinner();

      // For the first grid, first populate the dropdowns.
      populateQuadrantIndicatorDropdownsForGrid(1);

      // Load state early so that saved filter and grid settings are available.
      loadState();

      // Determine how many grids were saved.
      const savedStateStr = localStorage.getItem('dashboardState');
      let savedGridsCount = 1;
      let savedState = null;
      if (savedStateStr) {
        try {
          savedState = JSON.parse(savedStateStr);
          if (savedState.grids) {
            savedGridsCount = Object.keys(savedState.grids).length;
          }
        } catch (e) {
          console.error("Error parsing saved state:", e);
        }
      }

      // Create additional grids if needed.
      const gridContainer = document.getElementById("chartGridsContainer");
      const currentGrids = gridContainer.querySelectorAll(".charts-grid").length;
      for (let i = currentGrids + 1; i <= savedGridsCount; i++) {
        await createNewChartGrid();
      }

      // Now that all grids exist, restore grid-specific settings.
      loadState();

      document.getElementById("quadrantPlayButton1").addEventListener("click", () => {
        playQuadrantChart(1);
      });

      // Instead of always using default indicators, check for saved values.
      let savedLineIndicators = null;
      if (savedState && savedState.grids && savedState.grids["1"] && savedState.grids["1"].lineChartIndicators) {
        savedLineIndicators = savedState.grids["1"].lineChartIndicators;
      }

      // Create new chart instances for chartsContainer1 using saved values if available.
      if (savedLineIndicators && savedLineIndicators[0]) {
        createNewChartInstance(savedLineIndicators[0], "chartsContainer1", "x");
      } else {
        createNewChartInstance(defaultXIndicator, "chartsContainer1", "x");
      }
      if (savedLineIndicators && savedLineIndicators[1]) {
        createNewChartInstance(savedLineIndicators[1], "chartsContainer1", "y");
      } else {
        createNewChartInstance(defaultYIndicator, "chartsContainer1", "y");
      }

      // Load quadrant data and update the first grid.
      await loadQuadrantData(1);
      updateQuadrantChart(1);
      await updateAllCharts();

      setTimeout(() => {
        updateAllCharts();
        hideSpinner();
      }, 1000);
    });

    function populateQuadrantIndicatorDropdownsForGrid(gridSuffix) {
      const xSelect = document.getElementById("xIndicatorSelect" + gridSuffix);
      const ySelect = document.getElementById("yIndicatorSelect" + gridSuffix);
      // Clear any existing options
      xSelect.innerHTML = "";
      ySelect.innerHTML = "";
      indicators.forEach(ind => {
        const optX = document.createElement("option");
        optX.value = ind.value;
        optX.textContent = ind.text;
        xSelect.appendChild(optX);
        const optY = document.createElement("option");
        optY.value = ind.value;
        optY.textContent = ind.text;
        ySelect.appendChild(optY);
      });
      // Explicitly set the default values
      xSelect.value = defaultXIndicator;
      ySelect.value = defaultYIndicator;

      xSelect.addEventListener("change", () => {
        loadQuadrantData(gridSuffix);
        updateAllCharts();
      });
      ySelect.addEventListener("change", () => {
        loadQuadrantData(gridSuffix);
        updateAllCharts();
      });
    }
    function populateModalDropdowns() {
      const modalXSelect = document.getElementById("modalXIndicatorSelect");
      const modalYSelect = document.getElementById("modalYIndicatorSelect");
      modalXSelect.innerHTML = '';
      modalYSelect.innerHTML = '';
      indicators.forEach(ind => {
        const optX = document.createElement("option");
        optX.value = ind.value;
        optX.textContent = ind.text;
        modalXSelect.appendChild(optX);
        const optY = document.createElement("option");
        optY.value = ind.value;
        optY.textContent = ind.text;
        modalYSelect.appendChild(optY);
      });
      // Get current selections from the normal view dropdowns (for the current grid)
      const gridXSelect = document.getElementById("xIndicatorSelect" + currentModalGridSuffix);
      const gridYSelect = document.getElementById("yIndicatorSelect" + currentModalGridSuffix);
      modalXSelect.value = gridXSelect ? gridXSelect.value : defaultXIndicator;
      modalYSelect.value = gridYSelect ? gridYSelect.value : defaultYIndicator;

      modalXSelect.addEventListener("change", () => {
        redrawQuadrantChartInModal(currentModalGridSuffix);
      });
      modalYSelect.addEventListener("change", () => {
        redrawQuadrantChartInModal(currentModalGridSuffix);
      });
    }
  </script>

  <!-- jQuery UI Range Slider Initialization -->
  <script>
    $(function () {
      $("#yearSlider").slider({
        range: true,
        min: 1960,
        max: 2023,
        values: yearRange,
        slide: function (event, ui) {
          yearRange = ui.values;
          var baseText = $("#yearRangeDisplay").find(".translation").text();
          $("#dynamicYearRange").text(": " + ui.values[0] + " - " + ui.values[1]);
        },
        change: function (event, ui) {
          updateAllCharts();
        }
      });
      var baseText = $("#yearRangeDisplay").find(".translation").text();
      $("#dynamicYearRange").text(": " + yearRange[0] + " - " + yearRange[1]);
    });

  </script>

  <script>
    function saveState() {
      const state = {
        filters: {
          yearRange: $("#yearSlider").slider("values"),
          selectedCountries: window.selectedCountries,
          language: document.getElementById("languageSelector").value
        },
        grids: {},
        colors: {
          colorBg: getComputedStyle(document.documentElement).getPropertyValue('--color-bg').trim(),
          colorBgLight: getComputedStyle(document.documentElement).getPropertyValue('--color-bg-light').trim(),
          colorBgMedium: getComputedStyle(document.documentElement).getPropertyValue('--color-bg-medium').trim(),
          colorBgDark: getComputedStyle(document.documentElement).getPropertyValue('--color-bg-dark').trim(),
          colorText: getComputedStyle(document.documentElement).getPropertyValue('--color-text').trim(),
          // Speichere die Quadranten-Farben in einem eigenen Objekt:
          quadrant: {
            q1: getComputedStyle(document.documentElement).getPropertyValue('--quadrant-q1').trim(),
            q2: getComputedStyle(document.documentElement).getPropertyValue('--quadrant-q2').trim(),
            q3: getComputedStyle(document.documentElement).getPropertyValue('--quadrant-q3').trim(),
            q4: getComputedStyle(document.documentElement).getPropertyValue('--quadrant-q4').trim()
          }
        }
      };

      const gridElements = document.querySelectorAll(".charts-grid");
      gridElements.forEach(grid => {
        const gridSuffix = grid.id.replace('grid', '');
        const quadrantIndicators = {
          xIndicator: document.getElementById("xIndicatorSelect" + gridSuffix).value,
          yIndicator: document.getElementById("yIndicatorSelect" + gridSuffix).value
        };
        const chartsContainer = document.getElementById("chartsContainer" + gridSuffix);
        const lineChartIndicators = [];
        if (chartsContainer) {
          const selects = chartsContainer.querySelectorAll(".indicatorSelect");
          selects.forEach(sel => {
            lineChartIndicators.push(sel.value);
          });
        }
        state.grids[gridSuffix] = {
          quadrantIndicators,
          lineChartIndicators
        };
      });
      localStorage.setItem('dashboardState', JSON.stringify(state));
    }
    function loadState() {
      const stateStr = localStorage.getItem('dashboardState');
      if (!stateStr) {
        document.getElementById("languageSelector").value = "en";
        loadTranslations("en");
        return;
      }

      const state = JSON.parse(stateStr);

      if (state.filters) {
        // Aktualisiere den globalen yearRange-Wert
        if (state.filters.yearRange) {
          yearRange = state.filters.yearRange;
        }

        // Setze den Slider auf den gespeicherten Jahrbereich
        if (state.filters.yearRange && $("#yearSlider").hasClass("ui-slider")) {
          $("#yearSlider").slider("values", state.filters.yearRange);
          var baseText = $("#yearRangeDisplay").find(".translation").text();
          $("#yearRangeDisplay").text(
            baseText + ": " + state.filters.yearRange[0] + " - " + state.filters.yearRange[1]
          );
        }

        if (state.filters.selectedCountries) {
          window.selectedCountries = state.filters.selectedCountries;
          if (window.vueCountrySelectVm) {
            window.vueCountrySelectVm.value = state.filters.selectedCountries;
          }
        }

        if (state.filters.language) {
          document.getElementById("languageSelector").value = state.filters.language;
          loadTranslations(state.filters.language);
          $('#languageSelector').trigger('change');
        } else {
          document.getElementById("languageSelector").value = "en";
          loadTranslations("en");
        }
      } else {
        document.getElementById("languageSelector").value = "en";
        loadTranslations("en");
      }

      // Update grids' settings (if applicable)
      if (state.grids) {
        for (const gridSuffix in state.grids) {
          const gridState = state.grids[gridSuffix];

          const xSelect = document.getElementById("xIndicatorSelect" + gridSuffix);
          const ySelect = document.getElementById("yIndicatorSelect" + gridSuffix);
          if (xSelect && ySelect && gridState.quadrantIndicators) {
            xSelect.value = gridState.quadrantIndicators.xIndicator;
            ySelect.value = gridState.quadrantIndicators.yIndicator;
          }

          const chartsContainer = document.getElementById("chartsContainer" + gridSuffix);
          if (chartsContainer && gridState.lineChartIndicators) {
            const selects = chartsContainer.querySelectorAll(".indicatorSelect");
            selects.forEach((sel, index) => {
              if (gridState.lineChartIndicators[index]) {
                sel.value = gridState.lineChartIndicators[index];
              }
            });
          }
        }
      }

      // Lade Farbanpassungen, falls vorhanden
      if (state.colors) {
        document.documentElement.style.setProperty('--color-bg', state.colors.colorBg);
        document.documentElement.style.setProperty('--color-bg-light', state.colors.colorBgLight);
        document.documentElement.style.setProperty('--color-bg-medium', state.colors.colorBgMedium);
        document.documentElement.style.setProperty('--color-bg-dark', state.colors.colorBgDark);
        document.documentElement.style.setProperty('--color-text', state.colors.colorText);
      }
      // Prüfe, ob die Quadranten-Farben im State vorhanden sind und setze sie:
      if (state.colors && state.colors.quadrant) {
        document.documentElement.style.setProperty('--quadrant-q1', state.colors.quadrant.q1);
        document.documentElement.style.setProperty('--quadrant-q2', state.colors.quadrant.q2);
        document.documentElement.style.setProperty('--quadrant-q3', state.colors.quadrant.q3);
        document.documentElement.style.setProperty('--quadrant-q4', state.colors.quadrant.q4);
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      loadState();
    });
    document.getElementById("saveStateBtn").addEventListener("click", () => {
      saveState();
      console.log(localStorage)
      alert("State saved!");
    });
  </script>
  <script>
    Vue.component('treeselect', VueTreeselect.Treeselect);
    new Vue({
      el: '#vueCountrySelectContainer',
      data: { value: [], options: [], regionMapping: {} },
      watch: {
        async value(newVal) {
          let selectedIds = [];
          newVal.forEach(val => {
            if (countriesData.find(country => country.id === val)) {
              selectedIds.push(val);
            } else if (this.regionMapping[val]) {
              selectedIds = selectedIds.concat(this.regionMapping[val].map(country => country.id));
            }
          });
          window.selectedCountries = selectedIds;
          const gridContainer = document.getElementById("chartGridsContainer");
          const grids = gridContainer.querySelectorAll(".charts-grid");
          for (const grid of grids) {
            const gridSuffix = grid.id.replace('grid', '');
            await loadQuadrantData(gridSuffix);
          }
          await updateAllCharts();
        }
      },
      created() {
        const stateStr = localStorage.getItem('dashboardState');
        let savedCountries = [];
        if (stateStr) {
          try {
            const stateObj = JSON.parse(stateStr);
            if (stateObj.filters && stateObj.filters.selectedCountries) {
              savedCountries = stateObj.filters.selectedCountries;
            }
          } catch (e) {
            console.error("Error parsing saved state:", e);
          }
        }
        fetch("{{ url_for('static', filename='countries.json') }}")
          .then(response => response.json())
          .then(countries => {
            countriesData = countries;
            const regionsMap = {};
            countries.forEach(country => {
              let regionName = country.region.value.trim();
              if (!regionName) return;
              if (!regionsMap[regionName]) {
                regionsMap[regionName] = [];
              }
              regionsMap[regionName].push({ id: country.id, label: country.name });
            });
            this.regionMapping = regionsMap;
            this.options = Object.keys(regionsMap).map(region => ({
              id: region,
              label: region,
              children: regionsMap[region]
            }));
            if (savedCountries.length > 0) {
              this.value = savedCountries;
              window.selectedCountries = savedCountries;
            } else {
              this.value = ["USA", "CHN", "DEU", "IND"];
              window.selectedCountries = this.value;
            }
            updateAllCharts();
          })
          .catch(error => { console.error("Error loading countries.json:", error); });
      },
      mounted() {
        window.vueCountrySelectVm = this;
      }
    });
  </script>
  <script>
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const gridContainer = document.getElementById("chartGridsContainer");
        const grids = gridContainer.querySelectorAll(".charts-grid");
        grids.forEach((grid) => {
          const gridSuffix = grid.id.replace('grid', '');
          resetQuadrantChart(gridSuffix);
          loadQuadrantData(gridSuffix);
        });
        for (const gridId in chartInstances) {
          const instances = chartInstances[gridId];
          instances.forEach(instance => {
            if (instance.chart) {
              instance.chart.resize();
              instance.chart.update();
            }
          });
        }
      }, 300);
    });
  </script>

  <!-- Language Selection & Dashboard Selection -->
  <script>
    function formatState(state) {
      if (!state.id) {
        return state.text;
      }
      var flagCode = $(state.element).data('flag');
      var flagUrl = "https://flagcdn.com/w20/" + flagCode.toLowerCase() + ".png";
      var $state = $(
        '<span><img src="' + flagUrl + '" style="width:20px; margin-right:8px;" />' + state.text + '</span>'
      );
      return $state;
    }

    $(document).ready(function () {
      $('#languageSelector').select2({
        templateResult: formatState,
        templateSelection: formatState,
        minimumResultsForSearch: Infinity,
        width: '120px'
      });

      $('#languageSelector').on('change', function (e) {
        loadTranslations(e.target.value);
      });
    });

    // Initialize Select2 on the saved dashboards select element
    $(document).ready(function () {
      $('#savedDashboardsSelect').select2({
        placeholder: "Select Saved Dashboard",
        minimumResultsForSearch: Infinity,
        width: '200px' // Adjust the width as needed
      });
    });
  </script>
  <script>
  const translationBaseUrl = "{{ url_for('static', filename='') }}";
  function loadTranslations(language) {
    fetch(translationBaseUrl + language + '.json')
        .then(response => response.json())
        .then(translations => {
          document.querySelectorAll('[data-i18n]').forEach(element => {
            const key = element.getAttribute('data-i18n');
            if (translations[key]) {
              // Wenn ein Kindelement mit der Klasse "translation" vorhanden ist,
              // aktualisiere nur dessen Inhalt, ansonsten den gesamten Inhalt.
              const translationElement = element.querySelector('.translation');
              if (translationElement) {
                translationElement.textContent = translations[key];
              } else {
                element.textContent = translations[key];
              }
            }
          });
        })
        .catch(error => console.error('Error loading translations:', error));
    }
  </script>

  <!-- Presentation Creation Integration -->
  <script>
    async function generateDescription(promptText) {
      try {
        const response = await fetch("/api/groq_description", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ promptText })
        });
        if (!response.ok) {
          return "There is some noteworthy economic trend observed in the data.";
        }
        const data = await response.json();
        return data.description || "There is some noteworthy economic trend observed in the data.";
      } catch (err) {
        console.error("Error calling description endpoint:", err);
        return "There is some noteworthy economic trend observed in the data.";
      }
    }
    async function svgToDataUrl(svgElement) {
      const serializer = new XMLSerializer();
      const svgString = serializer.serializeToString(svgElement);
      const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.crossOrigin = 'anonymous';
      return new Promise((resolve, reject) => {
        img.onload = function () {
          const canvas = document.createElement('canvas');
          canvas.width = svgElement.clientWidth || svgElement.getBoundingClientRect().width;
          canvas.height = svgElement.clientHeight || svgElement.getBoundingClientRect().height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          URL.revokeObjectURL(url);
          resolve(canvas.toDataURL('image/png'));
        };
        img.onerror = function (e) {
          reject(e);
        };
        img.src = url;
      });
    }
    async function createPresentation() {
      function pxToInches(px) {
        return px / 96;
      }

      // Erstelle eine neue Präsentation
      let pres = new PptxGenJS();

      // Hole die aktuell gesetzten CSS-Variablen
      const computedStyle = getComputedStyle(document.documentElement);
      const bgColor = computedStyle.getPropertyValue('--color-bg').trim().replace('#', '');
      const bgLight = computedStyle.getPropertyValue('--color-bg-light').trim().replace('#', '');
      const textColor = computedStyle.getPropertyValue('--color-text').trim().replace('#', '');

      // Definiere den Slide Master mithilfe der ausgelesenen Farben
      pres.defineSlideMaster({
        title: "MASTER_SLIDE",
        background: { fill: bgColor },
        objects: [
          { rect: { x: 0, y: 0, w: "100%", h: 0.6, fill: { color: bgLight } } },
          { rect: { x: 0, y: "7.0", w: "100%", h: 0.4, fill: { color: bgLight } } }
        ],
        slideNumber: { x: 9.0, y: "7.1", color: textColor }
      });

      // Titel-Slide hinzufügen
      let titleSlide = pres.addSlide({ masterName: "MASTER_SLIDE" });
      titleSlide.addText("Dashboard Presentation", {
        x: 0.3,
        y: 0.25,
        w: 9,
        fontSize: 32,
        bold: true,
        color: textColor
      });
      titleSlide.addText("A Professional Overview of the Data", {
        x: 0.3,
        y: 1,
        w: 9,
        fontSize: 20,
        color: textColor
      });

      const gridContainer = document.getElementById("chartGridsContainer");
      const grids = gridContainer.querySelectorAll(".charts-grid");

      for (const grid of grids) {
        const gridSuffix = grid.id.replace("grid", "");

        const quadrantContainer = document.getElementById("quadrantChartContainer" + gridSuffix);
        try {
          // Erstelle ein Canvas-Bild des Quadrant-Charts
          const canvas = await html2canvas(quadrantContainer, {
            scale: window.devicePixelRatio * 2,
            useCORS: true,
            allowTaint: false,
            backgroundColor: null
          });
          const quadrantImageData = canvas.toDataURL("image/png");

          const xSelect = document.getElementById("xIndicatorSelect" + gridSuffix);
          const ySelect = document.getElementById("yIndicatorSelect" + gridSuffix);
          const xIndicatorText = xSelect ? xSelect.options[xSelect.selectedIndex].text : "X-Axis Indicator";
          const yIndicatorText = ySelect ? ySelect.options[ySelect.selectedIndex].text : "Y-Axis Indicator";
          const chartTitle = `${xIndicatorText} vs ${yIndicatorText}`;

          const promptText = `Provide a concise description for a quadrant chart showing ${xIndicatorText} vs ${yIndicatorText} trends.`;
          const description = await generateDescription(promptText);

          let quadSlide = pres.addSlide({ masterName: "MASTER_SLIDE" });
          quadSlide.addText(chartTitle, {
            x: 0.3,
            y: 0.25,
            w: 9,
            fontSize: 24,
            bold: true,
            color: textColor
          });

          quadSlide.addText(`X-Axis: ${xIndicatorText}`, {
            x: 0.55,
            y: 5.1,
            w: 9,
            fontSize: 16,
            color: textColor
          });
          quadSlide.addText(`Y-Axis: ${yIndicatorText}`, {
            x: -4.25,
            y: 0.3,
            w: 9,
            fontSize: 16,
            color: textColor,
            rotate: -90
          });
          quadSlide.addImage({
            data: quadrantImageData,
            x: 0.5,
            y: 1.5,
            w: 4.5,
            h: 3.5,
            sizing: { type: "contain", w: 4.5, h: 3.5 }
          });

          quadSlide.addText(description, {
            x: 5.2,
            y: 2.0,
            w: 4.0,
            h: 3.5,
            fontSize: 16,
            color: textColor,
            valign: pres.AlignV.top,
            align: pres.AlignH.left,
            bullet: false
          });
        } catch (err) {
          console.error("Error capturing quadrant chart:", err);
        }

        const chartsKey = "chartsContainer" + gridSuffix;
        if (chartInstances[chartsKey]) {
          let lineCharts = chartInstances[chartsKey];
          let lineSlide = pres.addSlide({ masterName: "MASTER_SLIDE" });
          lineSlide.addText(`Line Charts for Grid ${gridSuffix}`, {
            x: 0.3,
            y: 0.25,
            w: 9,
            fontSize: 24,
            bold: true,
            color: textColor
          });

          const numCharts = lineCharts.length;
          const availableWidth = 9;
          const chartWidth = availableWidth / numCharts;
          const chartHeight = chartWidth / 2;

          for (let i = 0; i < numCharts; i++) {
            const chartObj = lineCharts[i];
            const imageData = chartObj.chart.canvas.toDataURL("image/png");
            const xPos = 0.5 + i * chartWidth;

            const indicatorText = chartObj.indicatorSelect.options[chartObj.indicatorSelect.selectedIndex].text;
            const promptText = `Provide a concise description for a chart showing ${indicatorText} trends.`;
            const description = await generateDescription(promptText);

            let dropdownImageData = "";
            try {
              const rect = chartObj.indicatorSelect.getBoundingClientRect();
              const dropdownCanvas = await html2canvas(chartObj.indicatorSelect, {
                scale: window.devicePixelRatio,
                useCORS: true,
                allowTaint: false
              });
              dropdownImageData = dropdownCanvas.toDataURL("image/png");
            } catch (err) {
              console.error("Error capturing dropdown element:", err);
            }
            if (dropdownImageData) {
              lineSlide.addImage({
                data: dropdownImageData,
                x: xPos,
                y: 0.8,
                w: pxToInches(chartObj.indicatorSelect.getBoundingClientRect().width),
                h: pxToInches(chartObj.indicatorSelect.getBoundingClientRect().height),
                sizing: { type: "contain" }
              });
            }

            lineSlide.addImage({
              data: imageData,
              x: xPos,
              y: 1.3,
              w: chartWidth - 0.2,
              h: chartHeight,
              sizing: { type: "contain", w: chartWidth - 0.2, h: chartHeight }
            });

            lineSlide.addText(description, {
              x: xPos,
              y: 1.3 + chartHeight + 0.2,
              w: chartWidth - 0.2,
              h: 1.5,
              fontSize: 14,
              color: textColor,
              valign: pres.AlignV.top,
              align: pres.AlignH.left,
              bullet: false
            });
          }
        }
      }

      pres.writeFile({ fileName: "Professional_Dashboard_Presentation.pptx" });
    }

    document.getElementById("createPresentation").addEventListener("click", createPresentation);
  </script>
</body>

</html>
